\documentclass[12pt]{article}
\usepackage{fontspec}
\usepackage{polyglossia}
\setdefaultlanguage{russian}
\setmainfont[Mapping=tex-text]{CMU Serif}

\begin{document}

\textbf{Пунктуации}. Пунктуации - это специальные элементы, которые инъектируются в поток операторами и несут некоторый предикат. Пунктуации гарантируют, что за ними не придут элементы, удовлетворяющие заданному предикату. Пунктуации используются для того, чтобы разделить потенциально бесконечный поток на "смесь" конечных потоков со своими свойствами и определять границы этих потоков. Получение пунктуации нотифицирует о том, что свойства текущего потока изменились.

\textbf{Модель потоковой обработки (этот раздел - выжимка из статей)}.

$G = \{\Pi, E \}$

$\Pi$ - конечное множество процессов (вершин в физическом графе). У процесса $p$ есть состояние $s_p$.

$C \subseteq \Pi \times \Pi$ - множество каналов, $c_{ij} = (p_i,p_j) \in C$. У каждого процесса есть входные $I_p = \bigcup_{x \in \Pi} \{c_{xp} | (x,p) \in C\}$ и выходные $O_p = \bigcup_{x \in \Pi} \{c_{px} | (p,x) \in C\}$ каналы.

В графе есть процессы-истоки - $A \subseteq \Pi$, у которых нет входных каналов и процессы-стоки $\Omega \subset \Pi$, у которых нет выходных каналов.

$M$ - состояние каналов, т.е. элементы, которые могут быть отправлены между процессами.

Каждый процесс $p$ может обрабатывать следующие события:

\begin{itemize}
    \item Получение элемента от другого процесса: $e = <recv, m_{qp}>_p$
    \item Вычислительный шаг: $e = <proc,m,M_i>_p$, $m \in M$ - вход, $M_i$ - выход. Во время вычислительного шага меняется состояние $(s^{i}_p, m_i) \rightarrow (s^{i+1}, M_i)$.
    \item Отправка элемента в другой процесс: $e = <send, m_{qp}>_q$
\end{itemize}

$E_p$ - множество событий в рамках процесса $p$ (исполнение). Все события в рамках одгого процесса строго упорядочены: $E_p = \{e^{0}_p, e^{1}_p, e^{2}_p, ... ,e^{i}_p ... \}$.

$E = \bigcup_{p \in \Pi} E_p$ - глобальное исполнение. На элементах глобального исполнения можна задать частичный порядок.

\bigskip
{\centering{Определение}

Пусть есть исполнение $E$, и $e, e^{'}, e^{''} \in E$, частичный порядок (порождения) $\hookrightarrow$ удовлетворяет следующим свойствам:

\begin{enumerate}
    \item Если $e = <proc, m_i, M_i>, e^{'} = <proc, m_j, M_j>$ и $m_j \in M_i$, то $e \hookrightarrow e^{'}$
    \item $(e \hookrightarrow e^{'}) \land (e^{'} \hookrightarrow e^{''}) \Rightarrow e \hookrightarrow e^{''}$ (транзитивность)
\end{enumerate}
}

\bigskip
{\centering{Определение}

Пусть есть исполнение $E$, и $e, e^{'}, e^{''} \in E$, частичный порядок (зависимости) $\prec$ удовлетворяет следующим свойствам:

\begin{enumerate}
    \item $e \leq_p e^{'} \Rightarrow e \prec e^{'}$
    \item $e \hookrightarrow e^{'} \Rightarrow e \prec e^{'}$
    \item $(e \prec e^{'}) \land (e^{'} \prec e^{''}) \Rightarrow e \prec e^{''}$ (транзитивность)
\end{enumerate}
}

\textbf{Формализация пунктуаций}.

Пусть на множестве $M$ объявлен предикат $pred(x), x \in M$.

Тогда пунктуация это специальный элемент в потоке $m^{pred}, pred(x) \in m^{pred}$, такой, что для $\forall p,q \in \Pi$ выполняется:

\begin{enumerate}
    \item $e = <send,m^{pred}_{qp}>_q \Rightarrow \forall e^{'} >_q e, e^{'} = <send, x_{qp}>_q: \neg pred(x)$
    \item $e = <recv,m^{pred}_{qp}>_p \Rightarrow \forall e^{'} >_p e, e^{'} = <recv, x_{qp}>_p: \neg pred(x)$
\end{enumerate}

Т.е. пунктуация - это "обещание" процесса не отправлять дальше в поток элементы, удовлетворяющие определенным свойствам, которые задаются предикатом $pred(x)$. Процесс, отправивший пунктуацию дальше в поток по каналу, обязуется больше не отправлять в этот канал обозначенные элементы. Процесс, получивший пунктуацию, ожидает, что такие элементы через этот канал ему не придут.

Для того, чтобы послать пунктуацию дальше, процессу нужно дождаться получения пунктуаций со всех входных каналов. Таким образом, каждый процесс должен в свою очередь рассылать пунктуации по всем выходным каналам $O_p$. Так как количество процессов $||\Pi|| = L * S$, где $L$ - количество вершин в логическом графе, а $S$ - параллелизм, то можно считать, что $||O_p|| = O(||\Pi||)$. Тогда, асимптотически, количество таких отправленных сообщений (пунктуаций) - $O(||\Pi||^2 / G)$, где G - частота "начальной" отправки пунктуаций. То есть количество дополнительного трафика на механизм пунктуаций квадратически зависит от числа процессов.

Важное свойство пунктуаций - если все процессы-стоки получили пунктуации со всех входных каналов, то это значит, что все дальнейшие элементы (в смысле порядка зависимости) в системе не будут удволетворять заданному предикату, т.е.:

$$\forall p \in \Pi, s \in \Omega, i \in I_s, e^{si} = <recv, m^{pred}_{ps}>_s \Rightarrow \forall e \succ e^{si}, \neg pred(m), m \in e$$

На этом свойстве основан протокол консистентного снепшота стейта - сначала стоки отправляют пустые пунктуации в поток. Эти пунктуации "делят" поток по входным элементам, которые в данный момент в процессе обработки. Получение таких пунтуаций на всех выходах системы означает, что все входные элементы, запущенные в систему до этих пунктуаций на входе, уже обработались.

\textbf{Проблемы пунктуаций}. 

1. Пунктуации не подходят для потоковых графов с нелинейным исполнением, например, содержащих циклы. В этом случае, отправление обещания дальше по потоку, что оператор не породит определеных элементов недостаточно для гарантии, что такие элементы действительно не придут, потому что они могут вернуться через цикл. Мотивационный пример: сборка мусора в поиске в ширину для рекомендаций.

2. Пунктуации не подходят для разделения потока на небольшие части (в единицы элементов) из-за большого дополнительного трафика. Из-за этого они не подходят для отслеживания быстроизменяющихся свойств потока. Мотивационный пример 1: чистка состояния поcле каждого входного элемента - подсчет TF-IDF. Мотивационный пример 2: сохранение снепшотов состояния - чем чаще снепшоты, тем меньше задержка.

3. Неэффективность для отслеживания быстроизменяющихся свойств потока вместе с отсутствием единой точки аггрегации результатов привело к тому, что пунктуации не используются для оценки \textit{количественных} свойств потока. Мотивационный пример: отслеживание "горячих ключей" - получение нотификаций, когда количества элементов с определенным значением ключа, по которому происходит аггрегация в системе превышает заданный максимальный уровень.

\textbf{Что мы предлагаем}. Давайте сделаем фреймворк для отслеживания свойств потока через специального агента, которому операторы будут посылать информацию о принятых и отправленных ими элементах. Это позволит поддержать циклические графы, оценку количественных свойств, и, потенциально, уменьшит трафик. Для разделения потока без пунктуаций нам понадобятся специальные метки для элементов. Давайте формализуем нашу идею.

\textbf{Упорядочивание элементов}.

Для того, чтобы разработать аналогичный пунктуациям механизм, без броадкаста элементов по потоку, нужно задать на них порядок, т.к. мы больше не сможем "разделять поток" используя порядок, заданный на событиях в рамках процесса.

Пусть на множестве $M$ задана функция $\tau(x), x \in M$, причем на области значений этой функции задан частичный или полный порядок. Т.к. любое событие несет в себе элемент $m \in M$, будем считать, что функция $\tau$ определена также на множестве $E$.

Если порядок на $t(e)$ согласован с порядком в рамках процессов:

$$\forall p \in \Pi, e,e^{'} \in E: \tau(e) \leq \tau(e^{'}) \Rightarrow e <_p e^{'}$$

то можно будет разделить поток с помощью $\tau(e)$ и получить те же свойства разделения, что и при пунктуациях.

Если же порядок на $\tau(e)$ согласован еще и с порядком зависимости:

$$\forall e,e^{'} \in E: \tau(e) \leq \tau(e^{'}) \Rightarrow e \prec e^{'}$$

то можно разделять поток по зависимостям, что позволит реализовать протокол консистентного снепшота состояния.

Как реализовать функцию $\tau(x)$, обсудим далее (в реализации).

\textbf{Тракер}.

Тракер - это специальный процесс в системе (для простоты пока один), $t \in \Pi$, связанный каналами со всеми процессами, $\forall p \in \Pi \setminus \{t\}: (p,t) \in C, (t,p) \in C$.

Пусть, как и в случае пунктуаций, на множестве $M$ объявлен предикат $pred(x), x \in M$.

Тракер получает от всех процессов два вида сообщений:

\begin{enumerate}
    \item Обещание $promise = <pred, \tau_{p}>$ больше не отправлять элементы $m \in M$, такие, что $\tau(m) > \tau_{p} \land pred(m)$.
    \item Мета-информацию вида $meta = <recv/send, \tau(x), pred(x)>_{pt}$ для каждого события процесса recv или send (на самом деле не совсем для каждого, реализацию обсудим потом)
\end{enumerate}

В ответ тракер рассылает подписавшимся на него процессам сообщения вида $notification = <pred,\tau_n>$, такое, что $\forall p,q \in \Pi$:

$$e = <recv,m^{notif}_{tp}>_p \Rightarrow \forall e = <recv,x_{qp}>_p, \tau(e) > \tau_n : \neg pred(x)$$

Таким образом, с помощью тракера мы аналогично пунктуациям можем "разрезать" бесконечный поток на смесь потоков, удовлетворяющих разным свойствам (предикатам). В отличие от пунктуаций поток делится не с помощью инъектирования элементов в поток, а с помощью специальной функции $\tau$, на множестве значений которой задан порядок, гарантирующий те или иные свойства.

\textbf{Свойства тракера}.

Преимуществом тракера является асимптотически меньшее количество трафика - $O(||\Pi|| / G)$ (G - granularity).

Тракер подходит для циклических графов, потому что после получения обещания, он отслеживает, сколько еще элементы, удовлетворяющие предикату, будут находиться в системе.

Еще одним преимуществом является то, что тракер легко расширить для отслеживания количественных свойств потока, т.к. мета-ифнормация от процессов обрабатывается одним агентом.

Одной из проблем тракера является то, что элементы и нотификации идут по разным каналам и никак не синхронизированы из коробки. Для некоторых задач, например, снепшоты стейта, такая синхронизация важна. Как достичь аналогичной синхронизации с тракером расскажем в имплементации.

% оценить ограничения на масштабируемость
% 

\end{document}
