%%%% fs-run-ops Operations

\label {fs-ops}

The set of available operations is limited by the following list.

{\bf Map} applies user-defined transformation to the payload of input item. 

{\bf Flat map} applies user-defined function to the payload of input item. This function returns a sequence of new payloads. Each of these payloads is put into distinct data item. 

{\bf Filter} applies user-defined predicate to the payload of input item. If the result of predicate is positive, filter outputs initial item with updated trace of local times. Otherwise, filter outputs nothing.

{\bf Broadcast} replicates input item to the specified number of operations or sinks. 

{\bf Merge} operation is initialized with specified number of input nodes. Each input item from all input nodes is sent to the single output. It preserves ordering between input items.

{\bf Grouping} has two parameters: number called {\it window} and hash function. Grouping stores input items in distinct buckets by the value of the hash function applied to payload. When next in turn item is got in the grouping, it is put to the tail of corresponding bucket. After that, grouping outputs window-sized {\it tuple item}, which consists of the last items of this bucket. If the size of bucket is less than window, all items of bucket are taken. Notably, grouping is the only operation that maintains state.
	
Here and elsewhere, we assume that hash functions in grouping are perfect, i.e. do not have any collisions. However, practically, user can define equivalence relation to ensure that items with distinct payloads are got in the distinct buffers.
	
To completely clarify the semantics of this operation, consider the following example. The grouping accepts items with payload represented as natural numbers: 1,2,3, etc. The hash function returns 1 if the number is even and 0 otherwise. If the window is set to 3, the output is:

\[(1), (2), (1|3), (2|4), (1|3|5), (2|4|6), (3|5|7), (4|6|8)...\]

The result tuple is ordered by meta-information, the latter elemens were produced after the beginning ones. 

The important property of the grouping is that the result is uniquely determined by the last element in the tuple. Therefore, grouping is the bijective mapping. Additionally, the results among items with different values of hash function are independent.

\subsection{User-defined parameters}

\begin{enumerate}
  \item{Map function}
  \item{Flatmap function}
  \item{Filter predicate}
  \item{Grouping window}
  \item{Grouping hash function}
  \item{Hash-partitioning function of the inputs}
  \item{Graph itself: vertexed and edges}
\end{enumerate}

Grouping hash can be inherited from its input partitioning. Note, that non of this paramiters contains state-management. Therefore, business-logic is stateless. Despite this it is enough to implement MapReduce transformations of the stream.
