%%%%% fs-run-time-model  Computational  Model

\label {fs-model-section}
In our model the dataflow is represented by a directed graph. This graph does not contain information about physical execution, so further we call it {\it logical} graph or stream. Items are get into the stream through the node called {\it front} and get out through the node called {\it sink}. Fronts and sinks are detailed in the next section; now it is only important that fronts and sinks play the role of the graph enter and graph exit correspondingly. Each other node of the logical graph contains single operation, also called job. Edges show the order of these operations. The data items are processed one-by-one in a "streaming" manner. 

Notably, despite the fact that commonly dataflow graphs assumed to be acyclic (DAGs), our model does not have this restriction. Moreover, as we show further in this section, there are cases when cycles are required, e.g. for reduce step in MapReduce-based algorithms. 

In this section, firstly, the structure of items in the data stream is defined. After that, supported operations and their properties are introduced. Finally, the way to implement any MapReduce transformation using our model is described.

\subsection{The structure of data items}
Generally, the items of the stream are represented as payload and meta-information. It should be highlighted that meta-information is not provided by business logic. Instead of this, it is assigned when the payload element arrives to the front. 

\[DataItem := (payload, Meta)\]

The meta-information of data item is represented as {\it global time} and the trace of {\it local times}.

\[Meta := (GlobalTime, Trace)\]

Global time is assigned to data item once when the item enters the system. It is represented as the concatenation of nanoseconds since the epoch start and the identifier of front. Firstly, such design makes global time strongly monotonic relating to the single front. Secondly, it avoids assigning the same global time for distinct input elements. Global times can be compared lexicographically.

\[GlobalTime := (frontTs, frontId)\]

Local time is the concatenation of logical time of operation and the ordinal number of output item which we call {\it child id}. The logical time is represented as simple items counter within each operation. Therefore, child id is required, because some jobs can generate multiple items from one, e.g. flat map. When the item is ready to go out from the operation, its trace of local times is appended by new corresponding local time. The traces of local times can be compared lexicographically.

\[Trace := [LocalTime]\]
\[LocalTime := (logicalTime, childId)\]

Notably, in spite of the fact that initially there are no items with the same global time, they can be generated by some operations. The trace of local times is used to distinguish two elements with the same global time. The metas can be compared lexicographically: initially by global time and then by local time. The main purpose of the described meta-structure is to provide information for items invalidation which is detailed in the next section.

\subsection{Supported operations}
The set of available operations is limited by the following list.

{\bf Map} applies specified transformation to the payload of input item. Global time of the item is not changed and the trace of local times is appended by the new corresponding element.

{\bf Flat map} applies specified function to the payload of input item. This function returns a sequence of new payloads. Each of these payloads is put into distinct data item. Output items inherit global time from the initial. The traces of output items are appended by local times with the same logical time but distinct child id.

{\bf Filter} applies specified predicate to the payload of input item. If the result of predicate is positive, filter outputs initial item with updated trace of local times. Otherwise, filter outputs nothing.

{\bf Broadcast} replicates input item to the specified number of operations or sinks. Similarly to the flat map, the traces of replicated items are appended by local times with the same logical time but distinct child id. Broadcast is the only operation with multiple outputs.

{\bf Merge} operation is initialized with specified number of input nodes. Each input item from all input nodes is sent to the single output. It should be mentioned that merge operation does not provide any guarantees about the order of items. Global time of the item is not changed and the trace of local times is appended by the new corresponding element. Merge is the only operation with multiple inputs.

{\bf Grouping} has two properties: number called {\it window} and hash function. Grouping stores input items in distinct buckets by the value of the hash function applied to payload. When next in turn item is got in the grouping, it is put to the tail of corresponding bucket. After that, grouping outputs {\it cortege item}, which consists of the last window items of this bucket. If the size of bucket is less than window, all items of bucket are taken. Notably, grouping is the only operation that maintains state.
	
To completely clarify the semantics of this operation, consider the following example. The grouping accepts items with payload represented as natural numbers: 1,2,3, etc. The hash function returns 1 if the number is even and 0 otherwise. If the window is set to 3, the output is:

\[(1), (2), (1|3), (2|4), (1|3|5), (2|4|6), (3|5|7), (4|6|8)...\]

As it can be observed, the result of operation depends on the order of the input items. Currently, we assume that all items are got in the grouping in order defined by meta-information. The implementation details are described in the next section. 

The important property of the grouping is that the result is uniquely determined by the last element in the cortege. Therefore, grouping is the bijective mapping. Additionally, the results among items with different values of hash function are independent.

Cortege item inherits global time from the last element. The trace of cortege item is the trace of the last item appended with the corresponding local time.  

\subsection{MapReduce transformations on stream}





