%%%%% fs-run-time-model  Computational  Model

\label {fs-model-section}
In our model the dataflow is represented by a directed graph. This graph does not contain information about physical execution, so further we call it {\it logical} graph or stream. Each node of the logical graph contains single operation, also called job. Edges show the order of these operations. The data items are processed one-by-one in a "streaming" manner. Notably, despite the fact that commonly dataflow graphs assumed to be acyclic (DAGs), our model does not have this restriction. Moreover, as we show further in this section, there are cases when cycles are required, e.g. for reduce step in MapReduce-based algorithms. 

In this section, firstly, the structure of items in the data stream is defined. After that, supported operations and their properties are introduced. Finally, the way to implement any MapReduce transformation using our model is described.

\subsection{The structure of data items}
Generally, the items of the stream are represented as payload and meta-information. It should be highlighted that meta-information is not provided by business logic. Instead of this, it is assigned when the payload element arrives to the system in the module called {\it front}. Fronts are detailed in the next section; now it is only important that fronts play the role of the system enter. 

\[DataItem := (payload, Meta)\]

The meta-information of data item is represented as {\it global time} and the trace of {\it local times}.

\[Meta := (GlobalTime, Trace)\]

Global time is assigned to data item once when the item enters the system. It is represented as the concatenation of nanoseconds since the epoch start and the identifier of front. Firstly, such design makes global time strongly monotonic relating to the single front. Secondly, it avoids assigning the same global time for distinct input elements. Global times can be compared lexicographically.

\[GlobalTime := (frontTs, frontId)\]

Local time is the concatenation of logical time of operation and the ordinal number of output item which we call {\it child id}. The logical time is represented as simple items counter within each operation. Therefore, child id is required, because some jobs can generate multiple items from one, e.g. flat map. When the item is ready to go out from the operation, its trace of local times is appended by new corresponding local time. The traces of local times can be compared lexicographically.

\[Trace := [LocalTime]\]
\[LocalTime := (logicalTime, childId)\]

Notably, in spite of the fact that initially there are no items with the same global time, they can be generated by some operations. The trace of local times is used to distinguish two elements with the same global time. The main purpose of the described meta-structure is to provide information for items invalidation which is detailed in the next section.

\subsection{Supported operations}

\subsection{MapReduce transformations on stream}





