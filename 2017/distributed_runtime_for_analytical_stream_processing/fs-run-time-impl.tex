%%% fs-run-time-impl Implementation
\label{fs-impl}

\FlameStream\ is implemented in Java, using Akka framework for messaging and Apache Zookeeper for cluster management. The usage of Zookeeper mitigates the need for the dedicated master node.

From a user perspective, system provides an API to define processing in the terms of {\it ticks}. Tick is represented by a time interval and the graph that handles data items, which relate to this interval, according to the global time. To deploy a tick, client writes it directly to Zookeeper, whereas Zookeeper notifies workers when the new tick appears. As soon as tick ends, system starts to execute the next one if any was submitted to Zookeeper. Otherwise, processing is completely stopped.

The underlaying purpose of ticks is to provide an ability to periodically rebuild and redeploy graph. We keep in mind that the possible client of FlameStream is a system that automatically builds graph based on declarative language. However, such system cannot build it once and use without modifications, because the performance of graph execution can be influenced by current load, the performance of operations, metrics, etc. Hence, frequent graph redeployment is a crucial for our system. 

\subsection{Fault tolerance}
Currently, there are no any fault tolerance mechanisms implemented in our prototype. However, it is worth to share some initial thoughts on the topic.

Typically, distributed systems take into consideration the following types of failures:
\begin{itemize}
    \item Packet loss
    \item Node failure
    \item Network partitioning
\end{itemize}

Acker can determine the packet loss issue if it happens. Therefore, the part of the stream can be replayed by front if it supports some kind of reliable buffer.

Node failure also can be easily determined by the acker. The only difficulty is the loss of the grouping state, because it can lead to the fail of exactly-once semantics. Hence, there is a need for grouping state replication.

Support of network partitioning tolerance is not planned, because it requires an unavoidable loss of data. We believe that in this case, stream processing does not make sense.
