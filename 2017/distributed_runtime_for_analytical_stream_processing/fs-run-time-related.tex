%%%% fs-run-time-related  Related Work

\label {fs-related-section}

{\bf Deterministic processing and handling out-of-order items:}
Research works on this topic analyze different methods, but most of them are based on buffering. K-slack technique can be applied, if network delay is predictable \cite{Babu:2004:EKC:1016028.1016032}. The key idea of the method is the assumption that an event can be delayed for at most K time units. Such assumption can reduce the size of the buffer. However, in the real-life applications, it is very uncommon to have any reliable predictions about the network delay. IOP and OOP architectures~\cite{Cranor:2003:GSD:872757.872838, Arasu:2006:CCQ:1146461.1146463, Li:2008:OPN:1453856.1453890} are discussed in section~\ref{fs-collision}. The mechanism to control the trade-off between determinism and low latency is proposed in~\cite{Zacheilas:2017:MDS:3093742.3093921}. However, such approach only provides for relaxing determinism properties to achieve low latency if needed.

Optimistic techniques are less covered in literature. In \cite{Wei:2009:SSO:1559845.1559973} so-called {\it aggressive} approach is proposed. They introduced an idea of deletion messages that is very similar to our tombstone items. However, authors describe their idea in an abstract way and do not provide any techniques to apply their method for the arbitrary operations. Another optimistic strategy is detailed in \cite{Li2011}. This method is probabilistic: it guarantees the right order with some probability. Besides, it supports only the limited set of query operators.

{\bf Data flow:}
One specific detail of our computational model is cyclic data flow graphs. Naiad~\cite{Murray:2013:NTD:2517349.2522738} by Microsoft Research provides an implementation of this idea. Nevertheless, Naiad applies cycles only for iterative computations and allows for each operation to have its own state. Another similar concept of Naiad is the usage of logical timestamps to monitor progress. However, to propagate the latest timestamp the pessimistic approach of notifications broadcasting is defined. Therefore, with the assumption of infrequent out-of-order items, our optimistic behavior is more relevant.

In our model, map and group operations are used as core processing primitives. Google Dataflow~\cite{Akidau:2015:DMP:2824032.2824076} provides the same idea. The primary distinction is that Google Dataflow has different state model which does not support MapReduce stream processing tasks. Additionally, this model provides different window types for grouping. FlameStream grouping is aligned with fixed-sized sliding window, but it is possible to implement other kinds of windows by using cycle and grouping with window-affiliation hash.
