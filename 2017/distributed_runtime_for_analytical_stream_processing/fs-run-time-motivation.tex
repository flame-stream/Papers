%%%% fs-run-time-motivation  FlameStream motivation

\label{motivation-section}

Implementation of deterministic processing is tightly connected to system state management: if user defined operations are pure functions and the total order is preserved, the processing becomes deterministic. The first step to fulfill these conditions is already done by the most of existing stream processing systems. Instead of providing the handler for external storage they give user operation the state object, provide it with interface to change the state and finally store resulting state snapshot after operation completes~\cite{carbone2015apache, apache:storm, Noghabi:2017:SSS:3137765.3137770}.

If $B$ is business-logic operation, $x \in \mathbb{E}, Y \subset \mathbb{E}$ are input and output items, $h$---state handler and $s_t$---state object at time $t$ this change in contract could be illustrated in (\ref{flink-contract}). In modern setting $B$ becomes stateless and state management is done on the system side. This change allows the system to implement fault tolerance mechanisms, but it also opens the opportunity to implement deterministic processing.

\begin{equation}
\label{flink-contract}
Y = B(x, h) \Rightarrow (Y, s_t) = B(x, s_{t-1}) 
\end{equation}

The only difference of a state object $s_t$ from the other items in the stream is that state objects are produced, updated and consumed by the same operation. If system allows cyclic execution graphs~\cite{Murray:2013:NTD:2517349.2522738} this difference becomes obsolete, as we can transfer state object from operations output to its input. We treat state object as a part of the stream and we call it {\it drifting state}. Drifting state allows to move fault tolerance logic from user defined operations to common stream consistency mechanisms.

The second property of the system needed for deterministic processing is total order preservation. This one is quite challenging due to asynchronous nature of network. On the other hand we need to care about the order only in the operations that are order-sensitive. All stateless operations are tolerant to the out-of-order items. The more stateless operation we have, the easier the task becomes. Another important note is that calculations are partitioned and order between items from different partitions does not influence the result. Partition could be calculated at single compute unit, which allows us to implement ordering within single unit instead of system wide.

Taking into account above considerations we think that modern stream processing problem setup allows us to build a system that is able to provide deterministic processing with low performance overhead. The desired system properties are:
\begin{itemize}
    \item Computational model should be deterministic by design, i.e. it should produce deterministic results for any pipelines and business-logic.
    \item The performance overhead should be low in comparison with the existing systems.
\end{itemize}
We will use the following principles for our system:
\begin{itemize}
    \item Support cyclic execution graph
    \item Localize state management in terms of system operation type
    \item A data partition must be processed on a single node
    \item Map/Reduce completeness
\end{itemize}
