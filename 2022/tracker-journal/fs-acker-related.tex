\label {fs-acker-related}

A comparison between various substream management techniques is summarized in Table~\ref{solutions-overview-table}. To the best of our knowledge, the punctuations framework is the only substream management mechanism that supports arbitrary predicates. 
% Many state-of-the-art SPEs adapt punctuations for various substream management problems. 
Flink~\cite{Carbone:2017:SMA:3137765.3137777}, Storm~\cite{Toshniwal:2014:STO:2588555.2595641}, Samza~\cite{Noghabi:2017:SSS:3137765.3137770} apply punctuations for both window aggregations and state snapshotting problems. MillWheel~\cite{Akidau:2013:MFS:2536222.2536229} has another state management model but also uses punctuations as a window end indicator. 

Spark Streaming~\cite{Zaharia:2012:DSE:2342763.2342773} method for state pruning is based on the punctuations as well. A recent work~\cite{DBLP:journals/pvldb/BegoliACHKKMS21} proposes an idea that a centralized agent can aggregate watermarks. This agent computes minimum over all of its node watermarks and then broadcasts reports. However, the aggregation and reporting techniques are not detailed, so the formal properties of this approach are unclear. 

Several techniques aim to track some specific properties of a stream but do not provide the general substream management framework. Apache Storm {\em Acker}~\cite{apache:storm:acker} is a method for completeness monitoring that also uses XOR operation properties under the hood. It allows SPE to detect if some element has been lost during the processing. However, Acker does not provide mechanisms for tracking arbitrary substreams, so it is not applicable for window termination and state pruning problems. 

Naiad~\cite{Murray:2013:NTD:2517349.2522738} has a mechanism for tracking the progress of distributed iterative computations. This method can be used to check the convergence criteria of iterative algorithms or limit iterations. The main commonality between the Naiad progress tracker and the \tracker\ is that information about iterations or substreams is propagated through network channels which are not used for data processing. However, in \tracker\ all termination events are provided by the tracking agent, while in Naiad each node generates progress events based on information from all other nodes. It implies that the amount of extra traffic required by this mechanism is quadratic from the number of nodes even if all updates go through a centralized accumulator.

Another technique for tracking centralized iterative processing is introduced in~\cite{chandramouli2014trill}, but it is not yet adapted for distributed processing. Although these methods are robust for progress tracking, they are also currently unsuitable for window termination or state pruning problems.

There are also other works which apply predicates for filtering events in stream processing and complex event processing. Method for building optimized {\em push-pull} plans for complex event processing queries is proposed in~\cite{purtzel2022predicate}. A method for parallel complex event processing over the stream processing engine based on predicates for matching events is detailed in~\cite{hirzel2012partition}.

A novel approach to define analytics on user-defined event intervals is introduced in~\cite{awad2022d2ia}. This work focuses on a language that can express queries over user-defined event intervals. Authors implement this approach on top of the Apache Flink that internally use punctuations for window-based computations. Combining ideas provided by authors of this work with the notion of the substream for complex event processing can be an interesting direction of our future work.

% Another related research direction is the generation of substream termination signals from data producers. Some systems apply periodic scheme~\cite{Akidau:2013:MFS:2536222.2536229, Akidau:2015:DMP:2824032.2824076}, while others try to use knowledge about the content of the data. Adaptive approach~\cite{awad2019adaptive} does not use any information about data but takes into account arrival rate and delay. The enhancements of these methods can increase the applicability of substream management in practice.

% Most dependency tracking techniques employed in state-of-the-art stream processing systems are discussed in detail in Section~\ref{existing_solutions}. In this section we hightlight the differences between 

% Naiad~\cite{Murray:2013:NTD:2517349.2522738} uses a kind of similar to \tracker\ mechanism for tracking the progress of iterative computations. Within this method, each data item in a system is assigned with an {\em epoch} and a vector of logical timestamps called {\em loop counter}. Epoch is similar to our notion of {\em global time} concept but provided by an external user. The value on the $i$th position of the loop counter indicates the number of times this element went through the $i$th {\em loop context} (cycle) in a dataflow. Special distributed agents monitor for the items and their timestamps and notify when all elements reach some iteration number or all elements from an epoch are entirely processed. There are three main differences between the mentioned technique and the \tracker. Firstly, \tracker\ relies on the global identifier of an element provided by a system itself. Secondly, the protocol used in Naiad causes the enormous number of extra network messages that quadratically depend on the number of machines even with optimizations~\cite{Murray:2013:NTD:2517349.2522738}. Thirdly, Naiad's method uses counter updates (+1/-1) instead of XORs, hence update messages do not commutate. This fact complicates the implementation (especially distributed) of this method.

% The problems of transactional processing, providing for delivery guarantees, and fault tolerance, are extensively studied in recent years~\cite{Akidau:2013:MFS:2536222.2536229, Carbone:2017:SMA:3137765.3137777, thepaper, Wang:2019:LSF:3341301.3359653}. While state-of-the-art stream processing systems still provide high overhead on regular processing due to fault tolerance protocols, transactional processing, etc., we expect that this area will be studied further. As we mentioned above, a dependency tracking mechanism is an essential part of the solutions to these problems. Hence, \tracker\ can be applied to optimize the existing techniques.