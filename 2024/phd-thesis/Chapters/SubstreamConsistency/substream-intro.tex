Distributed stream processing engines (SPEs), such as Flink~\cite{carbone2015apache}, Heron~\cite{Kulkarni:2015:THS:2723372.2742788}, or MillWheel~\cite{Akidau:2013:MFS:2536222.2536229} aim to process intensive data streams at scale. They are deployed on clusters consisting of tens or even hundreds of nodes that receive input data elements one by one, process them, and update the internal state. These systems distribute data elements among all computational nodes in a cluster. Therefore, it is a challenging task to detect that a substream terminates system-wide. 

The following scenarios illustrate the practical importance of this problem.

\noindent {\bf Windowed aggregations}. One way to adapt a relational query to a streaming environment is to run it on a window of data elements. This way, an initial stream will be converted into a stream of query results for each window instance. This method is widely applied in online analytics~\cite{traub2018scotty} and is used for streaming SQL implementation~\cite{Begoli:2019:OSR:3299869.3314040}. The window definition, in this case, forms a substream. For example, a sliding window will define a substream for each message in the initial stream.

\noindent {\bf State pruning}. Most SPEs group a state by keys. SPEs use them for data partitioning. For example, the task is to aggregate news into stories assigning every news item a story tag. In this case, a story tag will be the key; the properties of the story that are needed for the tagging procedure will be the state. The number of stories is not limited, and to prevent overflow~\cite{Tucker:2003:EPS:776752.776780}, SPE can remove state for outdated keys, e.g., for completed stories. In this case, the stream is a mixture of substreams: one per story.  

\noindent {\bf State snapshotting}. Epoch-based state snapshotting is a popular recovery technique applied in Flink~\cite{Carbone:2017:SMA:3137765.3137777}, Storm~\cite{Toshniwal:2014:STO:2588555.2595641}, Samza~\cite{Noghabi:2017:SSS:3137765.3137770}, IBM Streams~\cite{jacques2016consistent}. This method divides a stream into a sequence of data element chunks called ({\em epochs}). When a regular epoch is {\em atomically} processed, an SPE takes a state snapshot. In case of failures, SPE can consistently recover the state from the snapshot~\cite{2015arXiv150608603C}. 

Each of these scenarios is a particular case of a problem of monitoring substreams emergence and termination that we call a {\em substream management problem}. A substream is a part of the stream such that all its elements satisfy some predicate. 
For example, in the case of state pruning, the predicate is {\em [a data element key equals to $K$]}, for time window aggregations, the predicate is {\em [a data element has a timestamp less than $T$]}, and for state snapshotting it is {\em [a data element belongs to the epoch $E$]}.

We focus only on two signals: substream start and its termination. Tracking a start of a substream is a straightforward task: the first event of a substream will naturally trigger its start. On the contrary, generating a substream termination event is a challenging task, and practical problems may require various properties:
\begin{itemize}
    \item Deterministic windowed join\footnote{given the identical sequences of input tuples, the identical output tuples will be produced} requires an order of termination signals to respect the order of input elements (termination events from data producers)~\cite{najdataei2019stretch, gulisano2016scalejoin}.
    \item An epoch is a substream that an SPE should process atomically. A termination event for an epoch should arrive before any elements of the next epoch~\cite{2015arXiv150608603C}.
    \item State pruning problem does not require any specific properties from termination events. However, late termination event receiving may cause sub-optimal memory utilization.
\end{itemize}

In this chapter, we design a formal model for the substream management problem, estimate the network traffic overhead for state-of-the-art substream management framework, and show the theoretical lower for the traffic overhead in this task. We also formally define properties of a substream management technique required by various problems, such as state snapshotting, to ensure that a newly proposed method satisfies them. 

We organize the rest of the chapter as follows: 
Section~\ref{fs-acker-preliminaries} formalizes the substream management problem and indicates its main properties. We reveal the optimal traffic overhead for the problem in Section~\ref{fs-acker-optimal}. In Section~\ref{fs-acker-punctuations}, we discuss state-of-the-art punctuation framework and demonstrate the properties of this substream management solution in terms of our formal model. We summarize the chapter in Section~\ref{fs-acker-summary}.