\label{fs-acker-design}

In this section, we focus on the core concepts of our dependency tracking method. In general, this mechanism bases on the following ideas:
\begin{itemize}
    \item Each ingested input item is assigned by a special label at a system entry
    \item Descendant elements inherit label from the original input record~\footnote{Further we demonstrate cases when a label can be modified}
    \item All labels are ordered by the time of corresponding input element arrival 
    \item Each operator shares information about labels of all arriving and outgoing element with a special (potentially distributed) agent called {\em \tracker}
    \item \tracker\ aggregates information about labels from all partitions of all operators
    \item \tracker\ provides notifications when it ensures that elements with certain labels have been entirely processed
    \item The order of produced notifications corresponds to the order of labels (order of input elements arrival)
\end{itemize}

In section~\ref{labeling}, we introduce a concept of {\em global time}: the ordered labels that are assigned to input data items. This framework allows us to logically group an input stream into small ordered pieces and to monitor the descendants of these pieces independently. We describe the method of global time generation and the guarantees that it provides. After that, we detail the relation between the global time, a system (node) time, and wall time. The global time transformation rules are also discussed.

In section~\ref{tracker_mechanism}, we propose the tracking mechanism itself and formulate basic requirements that a stream processing system must satisfy in order to employ \tracker . We demonstrate the way how \tracker\ aggregates service information from operators, and how it guarantees the order of notifications. Finally, in Section~\ref{tracker_examples}, we illustrate our tracking mechanism within two practical problems: completeness monitoring and state snapshotting.

\subsection{Data items labeling} \label{labeling}

\subsubsection{Global time concept} \label{fs-acker-gt}
The core concept of our design is \textit{global time}. Global time is used to make the order of notifications produced by the tracking mechanism correspondent with the order of input elements arrival. As we mentioned above, such correspondence is required by state snapshotting mechanisms: if the notification that input element arrived at (wall) time $t$ has been entirely processed is generated after the same notification for input element arrived at time $t+1$, state snapshots may become inconsistent~\cite{2015arXiv150608603C}.

To provide one more illustration why the order of notifications can be important let us suppose that a mobile device communicate with our system. The logs from the device are processed in the system and personalized feedback is finally sent back to the device. This scenario suppose low latency between logs analysis and feedback because we want to take into account the most recent behavior of the user. On the other hand, events are able to come to different system input nodes but must generate output one after another for consistent results. One of these events could be click to some object and the other ``like'' or some other sort of feedback to the clicked object. Suppose that we have a guarantee that ``click'' arrived at a system before the ``like''. In this case, system should deliver output of ``click'' item after the output of ``like'' item. If the order of notifications corresponds to the order of input elements arrival, system can simply output an element when the completeness notification for the corresponding input element is generated.

Global time is based on the assumption that we are able to order input elements up to some difference in wall time. In case where all elements are coming to the system through the same node this assumption is natural since we can compare elements by system time of their check-in. On the other hand, if elements are coming from different nodes we can compare generation times up to some guarantied maximum system time difference $\delta$. This way we can split the whole input stream into pieces of time length $\delta$ that are comparable by this mechanism. We call the time associated with each piece \textit{global time} $t$.

Using this notation we guarantee that all elements before true (wall) time $\tau$ are processed if all elements of \textit{global time} $\tau - \delta \le t \le \tau + \delta$ are processed. We reference this rule as \textit{processing order preservation} because this way we guarantee that induced output elements never will have a reverse order of their ancestors.

\begin{lemma}
\label{gt-lemma}
If all elements of \textit{global time} less or equal to $t + 1$ are processed, then all elements of wall time $\tau < t$ are processed.
\end{lemma}
\begin{proof}
Element of wall time $\tau$ can be assigned to three different global times due to lack of system time synchronization:
\begin{itemize}
    \item input node that has time later then the wall time, in the worst case this time is $\tau - \delta$ that belongs to global time $t - 1 \le t + 1$;
    \item node that has precise time $\tau$ that belongs to global time $t \le t + 1$;
    \item and in the worst case the element comes to front with time greater then actual $\tau + \delta$ this time belongs to $t + 1 \le t + 1$ global time.
\end{itemize}
as one can see all these cases give the global times less or equal than $t + 1$ which is supposed to be processed.
\end{proof}

Lemma~\ref{gt-lemma} allows us to connect wall time with the \textit{global time} that forms a basis for semantic guarantees. This connection is crucial when single client connects to different input nodes of the system (e.g. round-robin balancing). The same semantic is used in markers~\cite{Carbone:2017:SMA:3137765.3137777} concept: instead of global times conditions they simultaneously send a special item from all input nodes and after these elements reach the end of the pipeline generate the outputs of the current piece of input.

\subsubsection{Glabal time transformation}

In previous section we used a notion of processed elements. By elements processing we mean the chain of operations induced by some input elements. This chain is defined by logical execution graph of operations. Each node in this graph is a user-defined operation that process input elements one by one and outputs elements, that are then routed according to output node edges to some other operations. We suppose that output elements $O$ of each operation $f$ has the global time of its elements not lower than the global time of the input element $i$.

\begin{equation}
    O = f(i), \forall o \in O: t(o) \ge t(i)
\end{equation}

The dependencies rule could be even more strict, if we don't allow cycles in execution graph: the output global time will be exactly the global time of the input element. Though, in case of back-links, we want to be able to delay element to influence the future elements and this limits us to the proposed conditions. In this case we regard such elements as postponed input and remove them from consideration at time $t(i)$. As an example of such back-links we can use Nayad cycle counters mechanism~\cite{Murray:2013:NTD:2517349.2522738}. In their scheme they allow to delay element persistence in the system for more than one generation.

Using this assumption on the global time dependencies, we can easily proof that if system contains no elements of global time $t < t_0$, then no elements of time $t$ will be generated in future.

\subsection{\tracker\ 's mechanism} \label{tracker_mechanism}
In previous sections we have defined the main assumptions needed for \tracker\ to function. Using this assumptions we are now ready to define the tracking mechanism itself. We follow the idea of Acker introduced in Storm~\cite{Toshniwal:2014:STO:2588555.2595641}. The original idea is to send random long markers on each item before network transfer and after it. This way we are able to ensure that no elements are ``hang'' in the network using a single XOR operation on the set of such markers. We use this idea a bit differently: we track the way of the element down to output sending random markers in the following situations:
\begin{itemize}
    \item element enters the system;
    \item element is generated by operation;
    \item element is processed by some operation;
    \item element is ready for output.
\end{itemize}
Following these rules the accumulator element becomes zero iff all descendants of the input element are ready for the output. The next step is to group tracking of the elements by their global time. If such accumulator becomes zero, this means that all elements of this global time are successfully processed. To accumulate markers system-wide we introduce \tracker\ agent which is responsible for gathering tracking information and notification of interested agents on complete processing of the elements of the same global time. The implementation details of the \tracker\ are discussed in Section~\ref{fs-acker-impl}.

Using introduced mechanism we are now able to define the rule for defined in Section~\ref{fs-acker-gt} semantic. If all accumulators for global time $t \le t_0 + 1$ are empty, we can release the output elements induced by input of time $t_0$ to preserve the wall time order of the input elements. The proof of this statement directly follows our assumptions and \tracker\ guarantees.

Notably, if execution graph has no cycles and global time equals the global time of the input element, the condition on all accumulators $t \le t_0 + 1$ could be relaxed to $t = \{t_0, t_0 + 1\}$ which allows to make implementation of the \tracker\ even more straightforward.

\subsection{Examples} \label{tracker_examples}
In this section we show the application of the introduced mechanism to two popular tasks emerging in stream processing: completeness monitoring and state snapshotting. These tasks are usually addressed by different algorithms by \tracker\ allows to solve them both with introduction of a single agent.
\subsubsection{Completeness monitoring}

\subsubsection{State snapshotting}



