\label{fs-acker-design}

In this section we focus on the core concepts of our system. We start from the definition of \textit{global time}. This framework allows us to cut an input stream into independent pieces that are then processed one after another. After introduction of the global time we define assumptions on user-defined operations that are needed to define a element tracking mechanism. Then the tracking mechanism itself is introduced.

\subsection{Global time concept}
The core concept of our design is \textit{global time}, that is based on the assumption that we are able to order input elements up to some difference in time. In case where all elements are coming to the system through the same node this assumption is natural since we can compare elements by system time of their check-in.

On the other hand if elements are coming from different nodes we can compare generation times up to some guarantied maximum system time difference $\delta$. This way we can split the whole input stream into pieces of time length $\delta$ that are comparable by this mechanism. We call the time associated with each piece \textit{global time} $t$.

Using this notation we guarantee that all elements before true (wall) time $\tau$ are processed if all elements of \textit{global time} $\tau - \delta \le t \le \tau + \delta$ are processed.

\begin{lemma}
\label{gt-lemma}
If all elements of \textit{global time} less or equal to $t + 1$ are processed, then all elements of wall time $\tau < t$ are processed.
\end{lemma}
\begin{proof}
Element of wall time $\tau$ can be assigned to three different global times due to lack of system time synchronization:
\begin{itemize}
    \item input node that has time later then the wall time, in the worst case this time is $\tau - \delta$ that belongs to global time $t - 1 \le t + 1$;
    \item node that has precise time $\tau$ that belongs to global time $t \le t + 1$;
    \item and in the worst case the element comes to front with time greater then actual $\tau + \delta$ this time belongs to $t + 1 \le t + 1$ global time.
\end{itemize}
as one can see all these cases give the global times less or equal than $t + 1$ which is supposed to be processed.
\end{proof}

Lemma~\ref{gt-lemma} allows us to connect wall time with the \textit{global time} that forms a basis for semantic guarantees. This connection is crucial when single client connects to different input nodes of the system (e.g. round-robin balancing).

To illustrate why the global time concept is important lets suppose that a mobile device communicate with our system, the logs from the device are then processed in the system and personalized feedback is finally sent back to the device. This scenario suppose low latency between logs analysis and feedback because we want to take into account the most recent behavior of the user. On the other hand events are able to come to different system input nodes but must generate output one after another for consistent results. One of these events could be click to some object and the other ``like'' or some other sort of feedback to the clicked object. In this case our concept of the global time allows us to guarantee that ``like'' element will generate output after ``click'' is processed. The physical processing of elements could be done in reverse order but the user code is guaranteed to observe both elements before any output will be generated. See more details in the next section.

The same semantic is used in watermarks~\cite{Carbone:2017:SMA:3137765.3137777} concept: instead of global times conditions they simultaneously send a special item from all input nodes and after these elements reach the end of the pipeline generate the outputs of the current piece of input.

\subsection{Tracking formalisms}
In previous section we used a notion of processed elements. By elements processing we mean the chain of operations induced by some input elements. This chain is defined by logical execution graph of operations. Each node in this graph has a set of elements in the input and a set of outputs and the edges are routes elements between operations. We suppose that output elements $O$ of each operation $f$ has the global time of its elements not lower than the global time of the input element $i$.

\begin{equation}
    O = f(i), \forall o \in O: t(o) \ge t(i)
\end{equation}

The dependencies rule could be even more strict, if we don't allow cycles in execution graph: the output global time will be exactly the global time of the input element. Though, in case of back-links, we want to be able to delay element to influence the future elements and this limits us to the proposed conditions. In this case we regard such elements as postponed input and remove them from consideration at time $t(i)$. As an example of such back-links we can use Nayad cycle counters mechanism~\cite{Nayad}. In their scheme they allow to delay element persistence in the system for more than one generation.

Using this assumption on the global time dependencies, we can easily proof that if system contains no elements of global time $t < t_0$, then no elements of time $t$ wall elements of time $t_0$ generated their output at time $t_0$ and this output can be delivered.
\begin{lemma}
If all elements in the system have global time $t > t_0$, then all elements of time $t_0$ have generated all their output.
\end{lemma}
\begin{proof}
Lets suppose that there is exist an element of 
\end{proof}

\subsection{\tracker\ 's mechanism}
XORS, grouping by Global Times, and monotonicity. 

\subsection{Examples}

\subsubsection{Completeness monitoring}

\subsubsection{State snapshotting}



