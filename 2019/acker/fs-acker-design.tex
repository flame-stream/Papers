\label{fs-acker-design}

In this section we focus on the core concepts of our system. We start from the definition of \textit{global time}. This framework allows us to cut an input stream into independent pieces that are then processed one after another. After introduction of the global time we define assumptions on user-defined operations that are needed to define a element tracking mechanism. Then the tracking mechanism itself is introduced.

\subsection{Global time concept}
\label{fs-acker-gt}
The core concept of our design is \textit{global time}, that is based on the assumption that we are able to order input elements up to some difference in wall time. In case where all elements are coming to the system through the same node this assumption is natural since we can compare elements by system time of their check-in.

On the other hand if elements are coming from different nodes we can compare generation times up to some guarantied maximum system time difference $\delta$. This way we can split the whole input stream into pieces of time length $\delta$ that are comparable by this mechanism. We call the time associated with each piece \textit{global time} $t$.

Using this notation we guarantee that all elements before true (wall) time $\tau$ are processed if all elements of \textit{global time} $\tau - \delta \le t \le \tau + \delta$ are processed. We reference this rule as \textit{processing order preservation} because this way we guarantee that induced output elements never will have a reverse order of their ancestors.

\begin{lemma}
\label{gt-lemma}
If all elements of \textit{global time} less or equal to $t + 1$ are processed, then all elements of wall time $\tau < t$ are processed.
\end{lemma}
\begin{proof}
Element of wall time $\tau$ can be assigned to three different global times due to lack of system time synchronization:
\begin{itemize}
    \item input node that has time later then the wall time, in the worst case this time is $\tau - \delta$ that belongs to global time $t - 1 \le t + 1$;
    \item node that has precise time $\tau$ that belongs to global time $t \le t + 1$;
    \item and in the worst case the element comes to front with time greater then actual $\tau + \delta$ this time belongs to $t + 1 \le t + 1$ global time.
\end{itemize}
as one can see all these cases give the global times less or equal than $t + 1$ which is supposed to be processed.
\end{proof}

Lemma~\ref{gt-lemma} allows us to connect wall time with the \textit{global time} that forms a basis for semantic guarantees. This connection is crucial when single client connects to different input nodes of the system (e.g. round-robin balancing).

To illustrate why the global time concept is important lets suppose that a mobile device communicate with our system, the logs from the device are then processed in the system and personalized feedback is finally sent back to the device. This scenario suppose low latency between logs analysis and feedback because we want to take into account the most recent behavior of the user. On the other hand events are able to come to different system input nodes but must generate output one after another for consistent results. One of these events could be click to some object and the other ``like'' or some other sort of feedback to the clicked object. In this case our concept of the global time allows us to guarantee that ``like'' element will generate output after ``click'' is processed. The physical processing of elements could be done in reverse order but the user code is guaranteed to observe both elements before any output will be generated. See more details in the next section.

The same semantic is used in markers~\cite{Carbone:2017:SMA:3137765.3137777} concept: instead of global times conditions they simultaneously send a special item from all input nodes and after these elements reach the end of the pipeline generate the outputs of the current piece of input.

\subsection{Tracking formalisms}
In previous section we used a notion of processed elements. By elements processing we mean the chain of operations induced by some input elements. This chain is defined by logical execution graph of operations. Each node in this graph is a user-defined operation that process input elements one by one and outputs elements, that are then routed according to output node edges to some other operations. We suppose that output elements $O$ of each operation $f$ has the global time of its elements not lower than the global time of the input element $i$.

\begin{equation}
    O = f(i), \forall o \in O: t(o) \ge t(i)
\end{equation}

The dependencies rule could be even more strict, if we don't allow cycles in execution graph: the output global time will be exactly the global time of the input element. Though, in case of back-links, we want to be able to delay element to influence the future elements and this limits us to the proposed conditions. In this case we regard such elements as postponed input and remove them from consideration at time $t(i)$. As an example of such back-links we can use Nayad cycle counters mechanism~\cite{Murray:2013:NTD:2517349.2522738}. In their scheme they allow to delay element persistence in the system for more than one generation.

Using this assumption on the global time dependencies, we can easily proof that if system contains no elements of global time $t < t_0$, then no elements of time $t$ will be generated in future.

\subsection{\tracker\'s mechanism}
In previous sections we have defined the main assumptions needed for \tracker\ to function. Using this assumptions we are now ready to define the tracking mechanism itself. We follow the idea of Acker introduced in Storm~\cite{Toshniwal:2014:STO:2588555.2595641}. The original idea is to send random long markers on each item before network transfer and after it. This way we are able to ensure that no elements are ``hang'' in the network using a single XOR operation on the set of such markers~\footnote{XOR operation is commutative and as we send each marker twice the entire combination gives zero in the result.}. We use this idea a bit differently: we track the way of the element down to output sending random markers in the following situations:
\begin{itemize}
    \item element enters the system;
    \item element is generated by operation;
    \item element is processed by some operation;
    \item element is ready for output.
\end{itemize}
Following these rules the accumulator element becomes zero iff all descendants of the input element are ready for the output. The next step is to group tracking of the elements by their global time. If such accumulator becomes zero, this means that all elements of this global time are successfully processed. To accumulate markers system-wide we introduce \tracker\ agent which is responsible for gathering tracking information and notification of interested agents on complete processing of the elements of the same global time. The implementation details of the \tracker\ are discussed in Section~\ref{fs-acker-impl}.

Using introduced mechanism we are now able to define the rule for defined in Section~\ref{fs-acker-gt} semantic. If all accumulators for global time $t \le t_0 + 1$ are empty, we can release the output elements induced by input of time $t_0$ to preserve the wall time order of the input elements. The proof of this statement directly follows our assumptions and \tracker\ guarantees.

Notably, if execution graph has no cycles and global time equals the global time of the input element, the condition on all accumulators $t \le t_0 + 1$ could be relaxed to $t = \{t_0, t_0 + 1\}$ which allows to make implementation of the \tracker\ even more straightforward.

\subsection{Examples}
In this section we show the application of the introduced mechanism to two popular tasks emerging in stream processing: completeness monitoring and state snapshotting. These tasks are usually addressed by different algorithms by \tracker\ allows to solve them both with introduction of a single agent.
\subsubsection{Completeness monitoring}

\subsubsection{State snapshotting}



