\documentclass{vldb}

\usepackage[utf8]{inputenc}

\usepackage{graphicx}
\usepackage{url}
\usepackage{multirow}
\usepackage{array}
\usepackage{hyperref}
\usepackage{algorithm} % for algorithms
% \usepackage{algorithm2e} % for algorithms
\usepackage{algpseudocode}
% \usepackage{booktabs} % For formal tables

\usepackage{balance}  % for  \balance command ON LAST PAGE  (only there!)
\usepackage{caption}
\usepackage{subcaption}
\usepackage{tikz}
\usetikzlibrary{backgrounds, calc, positioning, fit, decorations.pathreplacing}
% \theoremstyle{remark}

\pagestyle{empty} % removes running headers

\newcommand{\PicScale}{0.5}
\newcommand {\FlameStream} {FlameStream}
\newcommand {\tracker} {trAcker}
\newcommand {\acker} {Acker}

\newtheorem{lemma}{Lemma}

% Include information below and uncomment for camera ready
\vldbTitle{Tracking Dependencies in Distributed Streaming Dataflows}
\vldbAuthors{Nikita Sokolov, Artem Trofimov, Igor Kuralenok, Nikita Marshalkin, and Boris Novikov}
\vldbDOI{https://doi.org/10.14778/xxxxxxx.xxxxxxx}
\vldbVolume{12}
\vldbNumber{xxx}
\vldbYear{2019}

\begin{document}

\title {Tracking Dependencies in Distributed Streaming Dataflows}

\numberofauthors{5}

\author{
\alignauthor
Nikita Sokolov\\
    \affaddr{ITMO University}\\
    \affaddr{Saint Petersburg, Russia}\\
    \email{faucct@gmail.com}
\alignauthor
Artem Trofimov\\
    \affaddr{Yandex}\\
    \affaddr{Saint Petersburg, Russia}\\
    \email{tomato@yandex-team.ru}
\alignauthor
Igor Kuralenok\\
    \affaddr{Yandex}\\
    \affaddr{Saint Petersburg, Russia}\\
    \email{solar@yandex-team.ru}
\and 
\alignauthor
Nikita Marshalkin\\
    \affaddr{VK}\\
    \affaddr{Saint Petersburg, Russia}\\
    \email{n.marshalkin@corp.vk.com}
\alignauthor
Boris Novikov\\
    \affaddr{National Research University Higher School of Economics}\\
    \affaddr{Saint Petersburg, Russia}\\
    \email{borisnov@acm.org}
}

\maketitle

\begin{abstract}
%The majority of state-of-the-art stream processing systems faces a problem of obtaining notifications when the specific set of input elements have already been applied to all operators in a dataflow. Such notifications are commonly used to take consistent state snapshots or to release all descendants of an input element atomically while preserving exactly-once delivery guarantee. To generate these notifications, there is a need to track dependencies between input and their descendants and to inform when all descendants have been completely processed. In this work, we propose a method for tracking dependencies between streaming elements that can be applied for both cyclic (iterative) and acyclic dataflows. We demonstrate that our technique has low latency and throughput overhead within various setups and can significantly outperform methods employed by state-of-the-art stream processing systems.

In distributed stream processing, it is hard to determine a correspondence between input and output elements due to complex transformations, filterings, and so on. On the other hand, mechanisms for taking consistent state snapshots and for transactional stream processing require understanding when a system has already processed a specific set of input elements and the elements induced by them. To achieve this understanding, one needs to track dependencies between items in a dataflow. In this work, we propose a method for monitoring dependencies between streaming elements that is applicable to cyclic dataflows, as well. Our technique is based on an agent that watches for the computational progress and broadcasts system notifications when certain elements processing is finished. These notifications indicate when a system completely processed all descendants of concrete input elements. We demonstrate that our technique provides low notification latency while having low throughput overhead on regular processing, and can outperform methods employed by state-of-the-art stream processing systems.

% In distributed stream processing, a system often needs to determine a correspondence between input and output elements, e.g. to take state snapshot affected by  or to release all descendants of an input element atomically while preserving exactly-once delivery guarantee. This task is hard due to complex transformations, filterings, producing multiple elements from a single, etc. 

\end{abstract}

% \keywords{Data streams, exactly-once, drifting state, optimistic OOP}

\thispagestyle{empty}

\section {Introduction}
\input {fs-acker-intro.tex}

\section{Background and Motivation}
\input {fs-acker-motivation}

\section{Dependency tracking design}
\input {fs-acker-design}

\section{Implementation}
\input {fs-acker-impl}

\section {Experiments}
\input {fs-acker-experiments.tex}

\section{Related Work}
\input {fs-acker-related.tex}

\section {Conclusion}
\input {fs-acker-conclusion.tex}

\bibliographystyle{abbrvurl}
% \bibliography{bibliography/flame-stream}
\bibliography{../../bibliography/flame-stream}

\end {document}

\endinput
