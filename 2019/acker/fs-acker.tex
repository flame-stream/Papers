\documentclass[sigconf]{acmart}

\usepackage{graphicx}
\usepackage{algorithm} % for algorithms
\usepackage{algpseudocode}
\usepackage{booktabs} % For formal tables
\usepackage{amsthm} % For claims

\theoremstyle{remark}

\settopmatter{printacmref=false, printccs=true, printfolios=true}
\pagestyle{empty} % removes running headers

\newcommand{\PicScale}{0.5}
\newcommand {\FlameStream} {FlameStream}
\newcommand {\tracker} {trAcker}
\newcommand {\acker} {Acker}
\begin{document}

\copyrightyear{2019} 
\acmYear{2019} 
\setcopyright{acmcopyright}
% \acmConference[BeyondMR'18]{Algorithms and Systems for MapReduce and Beyond }{June 15, 2018}{Houston, TX, USA}
% \acmBooktitle{BeyondMR'18: Algorithms and Systems for MapReduce and Beyond , June 15, 2018, Houston, TX, USA}
% \acmPrice{15.00}
% \acmDOI{10.1145/3206333.3209273}
% \acmISBN{978-1-4503-5703-6/18/06}

\title {Tracking Dependencies in Distributed Streaming Dataflows}

% \author{Nikita Sokolov}
% \affiliation{%
%   \institution{ITMO University}
%   \city{Saint Petersburg}
%   \country{Russia}}
% \email{faucct@gmail.com}

% \author{Artem Trofimov}
% \affiliation{%
%   \institution{Yandex}
%   \city{Saint Petersburg}
%   \country{Russia}}
% \email{tomato@yandex-team.ru}

% \author{Igor Kuralenok}
% \affiliation{%
%   \institution{Yandex}
%   \city{Saint Petersburg}
%   \country{Russia}}
% \email{solar@yandex-team.ru}

% \author{Nikita Marshalkin}
% \affiliation{%
%   \institution{VK}
%   \city{Saint Petersburg}
%   \country{Russia}}
% \email{n.marshalkin@corp.vk.com}

% \author{Boris Novikov}
% \affiliation{%
%   \institution{National Research University Higher School of Economics}
%   \city{Saint Petersburg}
%   \country{Russia}}
% \email{borisnov@acm.org}

\begin{abstract}
%The majority of state-of-the-art stream processing systems faces a problem of obtaining notifications when the specific set of input elements have already been applied to all operators in a dataflow. Such notifications are commonly used to take consistent state snapshots or to release all descendants of an input element atomically while preserving exactly-once delivery guarantee. To generate these notifications, there is a need to track dependencies between input and their descendants and to inform when all descendants have been completely processed. In this work, we propose a method for tracking dependencies between streaming elements that can be applied for both cyclic (iterative) and acyclic dataflows. We demonstrate that our technique has low latency and throughput overhead within various setups and can significantly outperform methods employed by state-of-the-art stream processing systems.

In distributed stream processing, it is hard to determine a correspondence between input and output elements due to complex transformations, filterings, producing multiple items from a single, and so on. On the other hand, mechanisms for taking consistent state snapshots and for transactional stream processing require notifications when a system has already processed a specific set of input elements together with all their descendants. To produce these notifications, one needs to track dependencies between items in a data flow. In this work, we propose a method for monitoring dependencies between streaming elements applicable to cyclic dataflows as well. We enrich each data item with a logical timestamp that identifies corresponding input items. We build a scalable method to watch for the computational progress and to notify when data flow contains no elements with specific timestamps. These notifications indicate when a system completely processed all descendants of concrete input elements. We demonstrate that our technique provides low notification latency while having almost no throughput overhead on regular processing, and can outperform methods employed by state-of-the-art stream processing systems.

% In distributed stream processing, a system often needs to determine a correspondence between input and output elements, e.g. to take state snapshot affected by  or to release all descendants of an input element atomically while preserving exactly-once delivery guarantee. This task is hard due to complex transformations, filterings, producing multiple elements from a single, etc. 

\end{abstract}

% \keywords{Data streams, exactly-once, drifting state, optimistic OOP}

\maketitle

\thispagestyle{empty}

\section {Introduction}
\input {fs-acker-intro.tex}

\section{Background and Motivation}
\input {fs-acker-motivation}

\section{Dependency tracking design}
\input {fs-acker-design}

\section{Implementation}
\input {fs-acker-impl}

\section {Experiments}
\input {fs-acker-experiments.tex}

\section{Related Work}
\input {fs-acker-related.tex}


\section {Conclusion}
\input {fs-acker-conclusion.tex}

\bibliographystyle{ACM-Reference-Format}
\bibliography{../../bibliography/flame-stream}

\end {document}

\endinput
