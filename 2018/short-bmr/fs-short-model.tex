\label {fs-short-model}

\FlameStream\ computational model shares common building blocks with other stream processing systems: logical and physicl graph, hash partitioning of load between multiple workers, FIFO channels between operations etc. In this section we descibe only core differences that allows as to achieve the goals defined in the introduction.

We found that any stateful transformation can be expressed in terms of two operations:

\begin {description}
  \item [Map] applies a user-defined function to the payload of an input item and returns a sequence of data items with transformed payloads. 
  \item [Grouping] constructs a single item containing a set of consecutive items that have the same value of load-balancing function. The maximum number of items is defined by parameter $Window Size$. 
\end {description}

In addition to this reduced set of operations, \FlameStream\ model allows cycles in a logical graph while such graphs are commonly assumed to be acyclic (DAGs).

If the stateful operation is expressed in a form of $(In, State) \rightarrow (Out, NewState)$ it can be implemented by grouping with $WindowSize = 2$ which groups two consecutive items: $In$ and $State$ into a signle tuple and the following map operation combines them together into a $NewState$. The $NewState$ is then is returned into a grouping via a cycle. The outline of the proposed method is shown on Figure 123321.

While actual cycles in physical graph can cause spikes in throughput they can be optimized out by preprocessor. The whole cycle can be computed localy an collapsed into a single function call.

{\bf TODO:}

\begin{itemize}
  \item State management can be move down the stream.
  \item Optimizm, tombstones see ~\cite{we2018seim}.
\end{itemize}
