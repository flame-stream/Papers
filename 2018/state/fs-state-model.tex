% %%% fs-state-model - Model

\label {fs-model-section}

In this section, we outline the lightweight deterministic model called {\em drifting state}. While it is described in details in~\cite{we2018adbis}, in this paper we mention properties, which play important roles in consistency enforcement techniques.

Determinism can be achieved in a stream processing system with the following straightforward approach:
\begin{enumerate}
    \item Preserve predefined total order of elements before each order-sensitive operation in a data flow
    \item Preserve the same order of output items
    \item Require all operations to be pure
\end{enumerate}

The order on elements can be defined using a natural order of input elements arrival, e.g., $x\in Cl(D)(a_t) < y\in Cl(D)(a_{t+1})$. If multiple elements are generated from one, the order between them is based on the order of generation. In this case, reorderings may occur only in a physical graph.

At first glance, total order maintenance is over-restrictive. It can be achieved, e.g., using buffering before each order-sensitive operation until punctuation or low watermark arrives ~\cite{Li:2008:OPN:1453856.1453890}. However, buffering can dramatically increase latency.

An underlying idea of drifting state model is a reduced set of available operations which are pure and can enforce order optimistically but are sufficient to implement any stateful streaming data flow. 
\subsection{Basic operations}

Any logical graph in the drifting state model is constructed using the following two operations:

{\bf Map} applies a user-defined function to an input item. It returns a sequence of new data items generated from the input one. An output sequence can be empty.

{\bf Grouping} stores input items into distinct buckets by the value of the input balancing function. When the next item arrives at the grouping, it is appended to the corresponding bucket. Each time the grouping outputs window-sized {\it tuple item}, which consists of the most recent (in terms of the defined order) items of this bucket. If the size of the bucket is less than the window, all items of the bucket are taken.

The following example illustrates the semantics of the operation. The grouping accepts items represented as natural numbers: 1,2,3, etc. The hash function returns 1 if the number is even and 0 otherwise. If the window is set to 3, the output elements are:

\[(1), (2), (1|3), (2|4), (1|3|5), (2|4|6), (3|5|7), (4|6|8)...\]

\subsection{Completeness of operations}

Any stateful transformation can be expressed by decomposing into map and grouping operations with a cycle~\cite{we2018adbis}. Let us illustrate it by the example of sum operation. In a typical setting, each element is combined with previous state value and released. Then, the state is updated. In our model, firstly each element is grouped with previous state element into the pair. After that, map operation delivers a combined result, updates the state, and returns it to the grouping through the cycle. A comparison between the classical state handling approach and the drifting state model is shown in Figure~\ref{classical-drifting}.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=.49\textwidth]{pics/classical-drifting}
  \caption{The comparison between typical state handling approach and drifting state model}
  \label {classical-drifting}
\end{figure}

We call this model a drifting state because operation states become ordinary data flow elements. Unlike a common approach, in this model user does not have direct access to state, and state management is done completely on the system side.

\subsection{Properties of operations}

In this setting, map operation is pure and order insensitive, and grouping operation is pure. Grouping operation is order-sensitive because it should group a new element with the exact previous state. Hence, a straightforward approach to achieve determinism is to enforce order before grouping. Fortunately, grouping can be implemented optimistically. The scheme is shown in Figure~\ref{optimistic-grouping}. The numbers on this figure represent the right order of elements. An arriving element 3 is out-of-order. We know that actually invalid pair (one; five) has been already released. In this case, the system generates valid pairs because it knows the right position of the element 3. Besides, an invalid pair with a special flag is resent. Let us call such elements {\em sentinels}. The purpose of sentinels is to seek and destroy previously released invalid pairs. Sentinels remove them from other groupings or intercept before delivery to end-user. Map functions are required to be pure in order to ensure that sentinels will go through exactly the same path as original pairs. This method is applicable to any number of subsequent groupings.
 
\begin{figure}[htbp]
  \centering
  \includegraphics[width=.35\textwidth]{pics/grouping-invalidation}
  \caption{An idea of optimistic grouping implementation}
  \label {optimistic-grouping}
\end{figure} 

\subsection{Output elements delivery}

As it was demonstrated in section~\ref{fs-formalism}, an element can be consistently released at the time of nullification. In this case, it is guaranteed that the element is processed and delivered atomically with all its derivatives. In order to enforce such atomicity, we buffer all output items in the very last nodes of the physical graph called {\em barriers}. The barrier must ensure that all dependent elements have already arrived before it can safely deliver them to end-user. This behavior allows us to ensure that all invalid elements are destroyed by the corresponding sentinels before delivery. This property is proved in~\cite{we2018adbis}, but the intuitive explanation is that we hold invalid elements in the barrier until sentinels arrive. 

\subsection{Dependency tracking}

Barriers require mechanisms for detecting dependencies between data flow elements. The well-known solution for dependency tracking is to inject special elements in a data flow. These elements go through the same path in a physical graph and "push through" preceding data flow elements. When such element arrives at the barrier, it means that buffered elements do not have in-flight dependencies. Flink checkpointing technique is based on this approach~\cite{Carbone:2017:SMA:3137765.3137777}. While it works well in systems that support only acyclic execution graphs, it is unclear how to handle such "pushing" elements in drifting state cycles. 

To solve this problem, each data item maintains a so-called {\em global time}. Global time is the minimal time of arrival among all input elements which affect a given one,  $GT(x)=min\{t:a_t\in Cl^{-1}(D)(x)\}$. The exact algorithms for computing and maintaining global time are detailed in~\cite{we2018adbis}, but the important property is that dependent in-flight elements have the same global time. 

On each input item, any operation in a physical graph sends to the special agent called Acker global time together with a checksum hash of the corresponding output item. Then, it sends global time and a checksum hash of the input item. Acker XORs all checksums grouped by global times and when the result becomes zero, it means that all items with a given global time were processed. In other words, it means that all derivatives of an input element with the arrival time $GT$ are in the barrier. When such event occurs, acker broadcasts a notification to the subscribers, e.g. barriers. In this approach, collisions are possible, but they are very unlikely in practice. The idea of Acker is adopted from Apache Storm~\cite{apache:storm}.

Figure~\ref{acker} illustrates acker functionality. Different shapes of items mean different data items. The ack for the sending of the triangular element is sent before the rectangular one. We expect the channel between the acker and each operation to be FIFO, so ack for the triangular item would be xored before the rectangular. So the two equal values are separated by a distinct one. This technique guarantees that the {\it XOR} for some global time is equal to zero only if there are no in-flight elements with a given global time.

\begin{figure}[htbp]
  \centering
  \includegraphics[scale=0.58]{pics/acker}
  \caption{The example of tracking dependencies using acker}
  \label {acker}
\end{figure}