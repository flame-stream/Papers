%%% fs-state-conclusion - Conclusion

\label {fs-conclusion-seciton}

We formalized the notion of streaming consistency guarantees and demonstrated that the property of determinism is tightly connected with the concept of exactly-once. Non-deterministic systems must preserve atomicity between state snapshotting and output elements releasing in order to achieve exactly-once. Therefore, most of the state-of-the-art stream processing systems use one of the following approaches for consistency maintenance: 
\begin{itemize}
    \item Enforcing determinism by micro-batching or buffering before each stateful operation
    \item Applying protocols that connect state snapshotting and data releasing in a transactional way
\end{itemize}

However, both methods experience difficulties with working under low-latency requirements (less than a second). In the first case, latency cannot be lower than batching period, while in the second case, the latency of some input elements is higher than the duration of a transaction.

We proposed mechanisms for achieving exactly once on top of {\em drifting state} model. Drifting state provides inexpensive determinism due to optimistic nature and low overhead on buffering. Because of the determinism, proposed protocols provide the following features:

\begin{itemize}
    \item Elements are processed one-by-one in a pure streaming manner without input buffering
    \item The processes of business-logic computations, state snapshotting and releasing output items work asynchronously and independently
\end{itemize}

We implemented the prototype of the proposed technique to examine its performance and scalability. Our experiments demonstrated that the introduced protocols for fault tolerance are scalable and provide remarkably low overhead within different computational layouts. Furthermore, the comparison with industrial stream processing solution indicated that our prototype can provide significantly lower latency in case of exactly once semantics.

Regarding future work, we plan to implement mechanisms for collaborative usage of the system. In particular, we aim to build convenient tools for partial reusing of execution graphs. An additional task that we intend to work on is the generation of execution graphs based on some declarative language.
