\label{fs-preliminaries}

In this section, we remind the main concepts of stream processing, that we use further in this paper. 

A distributed stream processing system is a shared-nothing distributed runtime, that can handle a potentially unlimited sequence of input items. Each item can be transformed several times before the final result is released from the system. Elements can be processed one-by-one or grouped into small input sets, usually called {\em micro-batches}. 

A user specifies required stream processing with a {\em logical graph}. Vertices of this graph represent operations and edges determine the data flow between tasks. A processing system maps the logical graph to a {\em physical} graph that is used to control actual distributed execution. Commonly, each logical operation is mapped to a number of physical tasks that are deployed to a cluster of computational units connected through a network. Each operation may be {\em stateless} or {\em stateful}. A system is usually responsible for state management in order to prevent inconsistencies.

An input element has {\em entered} if the system is aware of this element since that moment and takes some kind of responsibility for its processing. 
This concept can be implemented in a differently. 
For example,
 an  element has been entered when  it  has arrived at {\em Source} vertex in Flink, while   
an  element enters, when it is read or received by an input agent also called  {\em Source}   in Spark Streaming.

An output element has {\em left} the system if the element has been released to a consumer. 
Since that time system cannot observe it anymore. This concept can also be implemented differently in various systems. For instance, in Spark Streaming element leaves when it is pushed to output operation, e.g. written to HDFS or file. In Flink, element is delivered to end-user when it leaves from {\em Sink} vertex.   

It is important to note that input and output elements cannot be directly matched due to the possibility of complex transformations within the system. 
For instance, a single input element can be transformed into multiple ones.  The  resulting elements may be  processed in completely different ways and even influence each other. 
In general, it is hard to find out input elements on which  an output element depends. 
%  Hence, in general, it is hard to determine the input element by an output.
