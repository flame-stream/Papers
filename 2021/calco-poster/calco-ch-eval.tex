As we mentioned earlier, this work focuses on the problem of equivalent graph generation. The following challenges remain in the adaptation of our technique for end-to-end distributed dataflows optimization:

\textbf{Cost-model evolution.}
Our framework requires a complex cost model because a user may desire to include some business metrics in the optimization process, e.g., the quality of results or acceptable performance, as we demonstrated in the running example. Therefore, we need to provide rich tools for cost model customization and support them in a planner. 

\textbf{Runtime reconfiguration.}
When a processing system decides to reconfigure the current execution graph, it should gracefully migrate in-flight results to the new graph. In batch processing, some systems support this functionality, e.g., Spark Catalyst~\cite{armbrust2015spark}. Although of efforts on the topic~\cite{10.14778/3329772.3329777, grulich2020grizzly}, stream processing systems have a lack of such mechanism for global optimization, e.g., it is unclear how to estimate the cost of reconfiguration in comparison with the potential outcome from the more optimal graph.

\textbf{Improving contracts expressiveness and interoperability.}
Trivial contracts are not convenient enough to use in practice.
For example, if some operations need incoming data flows not to be filtered, adding new filter property makes a user add it to the prohibited properties set of input contracts of all such operations manually. We also aim to build an automatic contracts generation from popular declarative languages such as SQL.


% Before having runtime statistics, a reasonable execution graph should be chosen.
% To do that we need an information about the output data flow cardinalities of nodes.
% Seems like this information should be manually provided by the programmer.




% In this section we discuss successes and concerns of the proposed contract-based approach.

% \subsection{Contracts}

% As we saw, semantics of the custom operations can be naturally described by contracts.
% However it may be inconvenient to write all contracts as is.
% For example, if some operations need incoming streams not to be filtered, adding new filter property makes programmer to add it to all this operations manually.
% There are some ideas that should make defining CGraph more handy, here are some of them:
% \begin{itemize}
%     \item properties should be able to be grouped to use them together (prohibit all filter properties as one, for example),
%     \item some kind of properties may be prohibited by default,
%     \item interactive environment that hints, which attributes and properties are not yet satisfied for the nodes that form the graph semantics.
% \end{itemize}

% \subsection{Work scheme and optimization}

% Before having runtime statistics, a reasonable concrete graph should be chosen.
% To do that we need an information about the output stream cardinalities of nodes.
% Seems like this information should be manually provided by the programmer.

% There are no production-ready frameworks for distributed data processing that gather needed statistics for accurate concrete graph cost evaluation.
% Also none of them can dynamically reconfigure graph.

% Finally, it is needed to precisely compute cost function using the runtime statistics and also estimate the cost of the graph dynamic reconfiguration.

% \subsection{General implementation}

% We plan to develop libraries to be able to specify computations using CGraph on Python and Java.
