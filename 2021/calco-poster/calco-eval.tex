Semantics for the running example consists of the "fraudMetric" and "participants" nodes.
Environment has three sources, two one-arity operations and two two-arity operations.

For example let us consider contracts of the bid-auction join and the fraud metric.
Join requires "bid.auction" and "auction.id" attributes and sets "joinBA" property:
\begin{lstlisting}[language=Haskell]
em = Set.empty
s = Set.fromList
joinBA =
  ( InCont (s ["bid.auction"]) em em
  , InCont (s ["auction.id"]) em em
  , OutCont em (s ["joinBA"]) )
\end{lstlisting}

Fraud metric has one input contract with four alternatives: no join properties required, one or another join property, or two join properties required, and required attributes.

We implemented a prototype in Haskell with trivial contracts and execution graphs generation.
Our prototype generates 6 execution graphs corresponding to the CGraph of the running example.
