\label {fs-optimization-introduction}

Modern day data analytics commonly requires near real-time online processing of continuously changing data arriving from unbounded streams. A standard way of defining a stream processing pipeline is an execution graph, each node of which represents an operation performed over stream elements. However, a declarative approach to defining computations is widely preferred in data analytics, but it has not gained wide use in streaming systems. SQL, typically used for executing database queries, is an example of the declarative approach to data processing. Among the many advantages of SQL are its popularity and ease of adoption, as well as its support of windowed aggregations and joins, which are common tasks in stream processing. 

Applications of SQL in stream processing have been an area of active research for the last two decades; however, there have not been many productive attempts at proposing a standard for robust streaming SQL. One such attempt \cite{Begoli:2019:OSR:3299869.3314040} is fairly recent (2019); its predecessors, such as CQL \cite{Arasu:2006:CCQ:1146461.1146463}, haven't found much popularity, and modern stream processing engines (SPEs) typically implement only a subset of SQL features. We hope that with the recent efforts in providing a standard for streaming SQL, the declarative approach to stream processing gains popularity, which would mean that declarative streaming query optimization is a task of great current interest.

Optimization is one of the stages of executing a declarative query. The execution stages are as follows: first, a query is \textit{parsed} into an abstract syntax tree, each node of which represents a relational algebra operator; second, the query is simplified during the \textit{rewriting} phase into a logical plan (or graph; we will be using these two terms interchangeably in the following text); third, the logical plan is transformed into a physical plan during \textit{optimization}; finally, the query is \textit{executed} and the result is delivered to the user \cite{Pitoura2018processing}. The correspondence between queries and plans is not one-to-one: for each query, there can be multiple execution plans. The purpose of query rewriting is to reduce the space of execution plans and to standardize and simplify the query for further processing \cite{Pitoura2018rewriting}; as for optimization, the query planner transforms each logical operator into its physical implementation: for example, a join operation can be implemented using the hash join algorithm or the merge join algorithm \cite{Neumann2018optimization}, or a join operation in a distributed system might be preceded by sharding.  

Database query optimization is a well-researched topic \cite{astrahan1976system, haas1989extensible, graefe1993volcano}. 
The two common approaches to query optimization are rule-based and cost-based. Rule-based optimization applies data-independent transformations that are guaranteed to always improve performance. One such transformation is pushing filtration and projection operators down as low as possible unless it could influence other operators. Cost-based optimization estimates a cost function value for each considered plan and selects the plan with the minimum cost value. The cost function is typically a linear combination of expected I/O and CPU costs, with CPU costs of each operation estimated based on relation cardinality and operator selectivity. Therefore, cost-based optimization requires knowledge of statistical information \cite{Neumann2018optimization}. However, obtaining such knowledge in streaming systems presents certain difficulties, discussed further in the paper.

% гриззли оптимизируют на уровне отображения логического графа в исполнителя, а мы хотим оптимизировать сам логический граф 
% это не добавить а заменить
Efforts to optimize streaming queries execution in a distributed environment focus on finding a suitable mapping from a logical graph to a physical graph executed on a machine \cite{grulich2020grizzly, gedik2009code, kroll2019arc, schneider2012auto, gedik2008spade}; we are more interested in optimizing the logical graph itself before it is mapped to a physical graph. The problem of logical level declarative query optimization is currently relevant and presents a challenge.


In this paper we:
\begin{itemize}
% детальный анализ задачи опмтимизации для потоков и методов её решения -- это первый пункт
    \item Present a detailed analysis of the problem of SQL queries optimization in distributed stream processing and discuss challenges that arise within this problem;
    \item Describe preliminary experiments that we have conducted in order to demonstrate feasibility of streaming SQL optimization.
\end{itemize}

The remainder of this paper is structured as follows. First, we state the problem as illustrated by a running example (Section \ref{sec:fs-optimization-problem-statement}). Second, we list the challenges in adaptive optimization of streaming SQL queries (Section \ref{sec:fs-optimization-challenges}). Then, we present the preliminary experiments we executed on our running example to demonstrate the feasibility of the proposed approach to query optimization and discuss the results (Section \ref{sec:fs-optimization-experiments}). Finally, we discuss related work including effort on database and streaming query optimization (Section \ref{sec:fs-optimization-related-work}).     
