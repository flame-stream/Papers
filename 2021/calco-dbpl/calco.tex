\documentclass[sigconf]{acmart}

\usepackage{graphicx}
\usepackage{algorithm} % for algorithms
\usepackage{algpseudocode}
\usepackage{booktabs} % For formal tables
\usepackage{amsthm} % For claims
\usepackage{bbm} % indicator function
\usepackage{acmcopyright}

% listings
\usepackage{xcolor,listings}
\usepackage{textcomp}
\lstset{upquote=true}

% plots
\usepackage{pgfplots}

% table
\usepackage[flushleft]{threeparttable} % http://ctan.org/pkg/threeparttable
\usepackage{booktabs,caption}

\theoremstyle{remark}

\settopmatter{printacmref=false, printccs=true, printfolios=true}
\pagestyle{empty} % removes running headers

\newcommand{\PicScale}{0.5}
\newcommand {\FlameStream} {FlameStream}
\begin{document}

% \copyrightyear{2019}
% \acmYear{2019}
% \setcopyright{rightsretained}
% \acmConference[DEBS '19]{DEBS '19: The 13th ACM International Conference on Distributed and Event-based Systems}{June 24--28, 2019}{Darmstadt, Germany}
% \acmBooktitle{DEBS '19: The 13th ACM International Conference on Distributed and Event-based Systems (DEBS '19), June 24--28, 2019, Darmstadt, Germany}\acmDOI{10.1145/3328905.3332514}
% \acmISBN{978-1-4503-6794-3/19/06}

\title{Calco: a contract-based approach to \\declaratively specify distributed dataflows}

% \author{Alexander Chernokoz, Darya Sharkova, Artem Trofimov, Nikita Sokolov, Ekaterina Gorshkova, and Boris Novikov}
% \affiliation{%
% \institution{$^5$ ITMO University}
%   \city{St. Petersburg}
%   \country{Russia}
% }
% \affiliation{%
% \institution{$^1$Higher School of Economics}
% }
% \author{Artem Trofimov,$^ {1,2}$    Mikhail Shavkunov,$^3$    Sergey Reznick,$^4$     Nikita Sokolov,$^{5}$   Mikhail Yutman,$^3$ \\   Igor E. Kuralenok,$^1$    and  Boris Novikov$^ {3}$ }
% \affiliation{%
% \institution{$^1$JetBrains Research}
% }
% \affiliation{%
% \institution{$^2$Saint Petersburg State University}
% }
% \affiliation{%
% \institution{$^3$National Research University Higher School of Economics}
% }
% \affiliation{%
% \institution{$^4$ Kofax}
% }
% \affiliation{%
% \institution{$^5$ ITMO University}
%   \city{St. Petersburg}
%   \country{Russia}
% }
% \email{\string{trofimov9artem, mv.shavkunov, sergey.reznick, faucct, myutman, ikuralenok\string}@gmail.com, borisnov@acm.org}

% План статьи:

%  1 Аннотация + Интро - 2 колонки
%  a Распределенная обработка и ее виды. Есть MapReduce и батчи, есть потоки.
%  b Исторически, пайплайны распределенной обработки задавали графами исполнения (переход от Hadoop к Spark). Графы исполнения популярны, т.к. их можно задать кодом и версионировать как код, у них есть переиспользуемые единицы (вершины), их можно визуализировать. Однако, графы состоят из произвольных пользовательских операций, над которыми нет никакой заданной алгебры. Следовательно, графы можно оптимизировать очень ограниченно - если мы перестроим граф, то у нас нет возможности понять, остался ли он корректным.
%  c Еще один способ задания вычислений SQL - подход, основанный на реляционной алгебре, в котором через запрос задается результат, который необходимо получить. Пользуясь правилами реляционной алгебры можно получать гарантированно эквиваллентные графы исполнения из одного запроса и из них выбирать оптимальный. Однако, у SQL есть проблемы - через него нельзя выразить произвольное MapReduce преобразование, а user-defined функции не поддаются оптимизации, т.к. на них не распространяются правила реляционной алгебры.
%  d Наш подход - основан на задании алгебры над пользовательскими операциями через контракты. Таким образом, мы можем переставлять произвольные операции в соответсвии с правилами, которые задали пользователи. В частности, через наш подход выражается SQL - с соответствующими правилами в контрактах (пример?).
%  e Большое отличие распределенных от баз данных - обычно запросы выполняются долго и меняются редко, а данные меняются часто. Наш подход позволяет делать совместную оптимизацию запросов, заданных SQL и произвольными пользовательскими операциями через сведение к контрактам. Таким образом, открывается возможность переиспользовать уже запущенные операции, используя их в различных задачах.
%  2 Пример совместной оптимизации - 1 колонка
%  3 Описание контрактов - 1.5 колонки
%  4 Пример совместной оптимизации на контрактах - 1.5 колонки
%  5 Ссылки, вывод и related work + discussion & fw - 1.5 колонки

\begin{abstract}

    There are two general ways to define computations: imperative and declarative.
    The first one is more transparent for programmers, while the second one is more suitable for complex optimizations.
    One declarative definition can have multiple implementations, which makes it possible to choose the most optimal one.
    Accordingly, distributed dataflow can be specified in two ways: defining concrete execution graph and SQL.
    A concrete graph does not capture high-level information about the problem it solves, so a distributed data processing system cannot permute operations for performance purposes.
    Hence, graph optimization is generally a programmer concern, but real-world graphs can be big enough, that makes it hard to optimize them manually.
    Moreover, most of the necessary information for the graph cost evaluation is available only in runtime.
    SQL is popular for data analytics, and its optimization is well-researched.
    However, it is inconvenient or sometimes impossible to use SQL for general data management tasks, such as ETL, machine learning pipelines, etc.

    In this work, we introduce a novel approach to specify distributed dataflows.
    Our method is based on declarative specifications of user-defined operations that we call contracts.
    Such specifications allow us to automatically generate execution graphs with the needed semantics to choose the most optimal one.
    An arbitrary operation or a dataflow part can be described by contracts, so this approach combines the transparency and flexibility of the imperative approach and optimization possibilities of the declarative one.
    We implement a prototype and demonstrate automatic graphs generation on a real-world dataflow (TODO).
    We also outline the challenges that we face regarding the optimization problem.

\end{abstract}

% \begin{CCSXML}
% \begin{CCSXML}
% \begin{CCSXML}
% <ccs2012>
% <concept>
% <concept_id>10002951.10002952.10002953.10010820.10003208</concept_id>
% <concept_desc>Information systems~Data streams</concept_desc>
% <concept_significance>500</concept_significance>
% </concept>
% <concept>
% <concept_id>10002951.10003317.10003347.10003356</concept_id>
% <concept_desc>Information systems~Clustering and classification</concept_desc>
% <concept_significance>500</concept_significance>
% </concept>
% <concept>
% <concept_id>10002951.10003227.10003351.10003446</concept_id>
% <concept_desc>Information systems~Data stream mining</concept_desc>
% <concept_significance>300</concept_significance>
% </concept>
% </ccs2012>
% \end{CCSXML}

% \ccsdesc[500]{Information systems~Data streams}
% \ccsdesc[500]{Information systems~Clustering and classification}
% \ccsdesc[300]{Information systems~Data stream mining}

% \keywords{Data streams, text classification, reproducibility, exactly once}

\maketitle

\thispagestyle{empty}

\section{Introduction}
\input{calco-intro}

\section{Running example}
\input{calco-example}

\section{Calco overview}
\input{calco-overview}

\section{Example evaluation}
\input{calco-eval}

\section{Discussion and future work}
\input{calco-disc-fw}

\section{Related work}
\input{calco-related}

\section{Conclusion}
\input{calco-conclusion}

\bibliographystyle{ACM-Reference-Format}
\bibliography{../../bibliography/flame-stream}

\end{document}

\endinput
