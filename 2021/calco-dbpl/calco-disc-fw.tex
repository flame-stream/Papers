In this section we discuss advantages and concerns of the proposed contract-based approach.

\subsection{Contracts}

As we saw, semantics of the custom operations can be naturally described by contracts.
However it may be inconvenient to write all contracts as is.
For example, if some operations need incoming streams not to be filtered, adding new filter property make programmer to add it to this operations manually.
There are some ideas that should make defining CGraph more handy, here are some of them:
\begin{itemize}
    \item properties should be able to be grouped to use them together (prohibit all filter properties as one, for example),
    \item some kind of properties may be prohibited by default,
    \item interactive environment that hints, which attributes and properties are not yet satisfied for the semantics nodes.
\end{itemize}

\subsection{Work scheme and optimization}

Before having runtime statistics reasonable concrete graph should be chosen.
To do that information is needed, how nodes change dataflow cardinality.
Seems like this information should be manually provided by the programmer.

There are no production-ready frameworks for distributed data processing that gather needed statistics for accurate concrete graph cost evaluation.
Also none of them can dynamically reconfigure graph.

Finally, it is needed to precisely compute cost function using the runtime statistics and also estimate the cost of the graph dynamic reconfiguration.

\subsection{General implemenation}

We plan to develop some libraries to be able to specify computations using CGraph on Python and Java.
