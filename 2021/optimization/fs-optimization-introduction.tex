\label {fs-optimization-introduction}

Modern day data analytics commonly requires near real-time online processing of continuously changing data arriving from unbounded streams. A standard way of defining a stream processing pipeline is an execution graph, each node of which represents an operation performed over stream elements. However, a declarative approach to defining computations is widely preferred in data analytics, but the known advantages of the declarative approach have not gained wide use in streaming systems. SQL, typically used for executing database queries, is one of the implementations of the declarative approach to data processing. Among the many advantages of SQL are its popularity and ease of adoption, as well as its support of windowed aggregations and joins, which are common tasks in stream processing. 

Application of SQL to stream processing has been an area of active research for the last two decades; however, there have not been many productive attempts at proposing a standard for robust streaming SQL. One such attempt \cite{Begoli:2019:OSR:3299869.3314040} is fairly recent (2019); its predecessors, such as CQL \cite{Arasu:2006:CCQ:1146461.1146463}, haven't found much popularity, and modern stream processing engines (SPEs) typically implement only a subset of SQL features. We hope that with the recent efforts in providing a standard for streaming SQL the declarative approach to stream processing gains popularity, which would mean that declarative streaming query optimization is a task of great current interest.

Optimization is one of the stages of executing a declarative query. The execution stages are as follows: first, a query is \textit{parsed} into an abstract syntax tree, each node of which represents a relational algebra operator; second, the query is simplified during the \textit{rewriting} phase into a logical plan (or graph; we will be using these two terms interchangeably in the following text); third, the logical plan is transformed into a physical plan during \textit{optimization}; finally, the query is \textit{executed} and the result is delivered to the user \cite{Pitoura2018processing}. The correspondence between queries and plans is not one-on-one; for each query, there can be multiple execution plans. The purpose of query rewriting is to reduce the space of execution plans and to standardize and simplify the query for further processing \cite{Pitoura2018rewriting}; as for optimization, the query planner transforms each logical operator into its physical implementation: for example, a join operation can be implemented using the hash join algorithm or the merge join algorithm \cite{Neumann2018optimization}, or a join operation in a distributed system might be preceded by sharding.  

Database query optimization is a well-researched topic \cite{astrahan1976system, haas1989extensible, graefe1993volcano}. 
The two common approaches to query optimization are rule-based and cost-based. Rule-based optimization applies data-independent transformations that are guaranteed to always improve the performance. One such transformation is pushing filtration and projection operators down as low as possible unless it could influence other operators. Cost-based optimization estimates a cost function value for each considered plan and selects the plan with the minimum cost value. The cost function is typically a linear combination of expected I/O and CPU costs, with CPU costs of each operation estimated based on relation cardinality and operator selectivity. Therefore, cost-based optimization requires knowledge of statistical information \cite{Neumann2018optimization}. However, obtaining such knowledge in streaming systems presents certain difficulties, discussed further in the paper.


The research on streaming SQL query optimization is scarce due to the previous lack of a uniform standard. Efforts to optimize streaming queries execution mostly focus on physical level optimizations \cite{grulich2020grizzly, gedik2009code} and not logical level optimizations, especially for SQL queries in particular. Therefore, the problem of logical level declarative query optimization is currently relevant and presents a challenge.


In this paper we:
\begin{itemize}
    \item Identify which features stream processing engines lack in order to support query execution graph optimization at the logical level;
    \item Describe preliminary experiments that we have conducted in order to demonstrate feasibility of streaming SQL optimization;
    \item Outline the next steps in implementing streaming SQL optimization support; % in dire need of a synonym
\end{itemize}

The remainder of this paper is structured as follows. First, we state the problem as illustrated by a running example (Section \ref{sec:fs-optimization-problem-statement}). Second, we list the challenges in adaptive optimization of streaming SQL queries (Section \ref{sec:fs-optimization-challenges}). Then, we present the preliminary experiments we executed on our running example to demonstrate the feasibility of the proposed approach to query optimization (Section \ref{sec:fs-optimization-experiments}) and discuss the results (Section \ref{sec:fs-optimization-discussion}). Finally, we discuss related work (Section \ref{sec:fs-optimization-related-work}).     



