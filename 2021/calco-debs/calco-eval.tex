\label{sec:eval}
\subsection{Running example CGraph specification}

Now we are ready to specify our example problem as CGraph.
We will see that such specification is at most a copy of the task description and it is easy to write.
Remind that CGraph is a pair of environment and semantics:
\begin{lstlisting}[language=Haskell]
cgraph :: CGraph
cgraph = (env, semantics)
\end{lstlisting}

Our goal in this task is to accumulate statistics and send it to the dashboard.
Operation named "stats" do it, so we write CGraph semantics in the following way:
\begin{lstlisting}[language=Haskell]
semantics :: Semantics
semantics = Set.fromList ["stats"]
\end{lstlisting}

Secondly, we need to specify environment and the "stats" contract in it for example:
\begin{lstlisting}[language=Haskell]
env :: Env
env = Env
  { streams = -- ...
  , tfms1 = Map.fromList
    [ -- ...
    , "stats"
      `ap1` emptyIn
        { attrsI = attrs
            [ "front.userId", "front.ts"
            , "back.ts", "back.payload"]
        , propsI = props
            [ "sessional"
            , "frontsFiltered"
            , "authoredUsers"] }
      -->  emptyOut { attrsO = delAttrs }
    ]
  ,tfms2 = -- ...
  }
\end{lstlisting}



TODO Way of reasoning about problems by contracts in declarative way \\
TODO

\subsection{Generated graphs and optimization}

TODO Optimal graph in the generated set \\
TODO Examples of graphs \\
TODO Graphs generation time \\
TODO

\subsection{SQL pipeline example}

TODO Second example from SQL bench
TODO
