\label{sec:eval}
\subsection{Running example by CGraph}

Now we are ready to specify our example problem as CGraph.
We will see that such specification is at most a copy of the task description and it is easy to write.

Our goal in this task is to calculate statistics and send it to the dashboard.
Operation named "stats" do it, so we write CGraph semantics in the following way:
\begin{lstlisting}[language=Haskell]
semantics :: Semantics
semantics = Set.fromList ["stats"]
\end{lstlisting}

Now we need to describe stats requirements:
\begin{lstlisting}
"stats"
`ap1` emptyIn
  { attrsI = attrs
    [ "front.userId", "front.ts"
    , "back.ts", "back.payload"]
  , propsI = props
    [ "sessional", "frontsFiltered"
    , "authoredUsers"] }
 -->  emptyOut { attrsO = delAttrs }
\end{lstlisting}


TODO Way of reasoning about problems by contracts in declarative way \\
TODO

\subsection{Generated graphs and optimization}

TODO Optimal graph in the generated set \\
TODO Examples of graphs \\
TODO Graphs generation time \\
TODO

\subsection{SQL pipeline example}

TODO Second example from SQL bench
TODO
