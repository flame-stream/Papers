\documentclass[sigconf]{acmart}

\usepackage{graphicx}
\usepackage{algorithm} % for algorithms
\usepackage{algpseudocode}
\usepackage{booktabs} % For formal tables
\usepackage{amsthm} % For claims
\usepackage{bbm} % indicator function
\usepackage{acmcopyright}

% listings
\usepackage{xcolor,listings}
\usepackage{textcomp}
\lstset{upquote=true}

% plots
\usepackage{pgfplots}

% table
\usepackage[flushleft]{threeparttable} % http://ctan.org/pkg/threeparttable
\usepackage{booktabs,caption}

\theoremstyle{remark}

\settopmatter{printacmref=false, printccs=true, printfolios=true}
\pagestyle{empty} % removes running headers

\newcommand{\PicScale}{0.5}
\newcommand {\FlameStream} {FlameStream}
\begin{document}

% \copyrightyear{2019}
% \acmYear{2019}
% \setcopyright{rightsretained}
% \acmConference[DEBS '19]{DEBS '19: The 13th ACM International Conference on Distributed and Event-based Systems}{June 24--28, 2019}{Darmstadt, Germany}
% \acmBooktitle{DEBS '19: The 13th ACM International Conference on Distributed and Event-based Systems (DEBS '19), June 24--28, 2019, Darmstadt, Germany}\acmDOI{10.1145/3328905.3332514}
% \acmISBN{978-1-4503-6794-3/19/06}

% TODO dataflows: is space needed
\title{Calco: a contract-based approach to specify distributed dataflows}

% \author{Alexander Chernokoz, Darya Sharkova, Artem Trofimov, Nikita Sokolov, Ekaterina Gorshkova, and Boris Novikov}
% \affiliation{%
% \institution{$^5$ ITMO University}
%   \city{St. Petersburg}
%   \country{Russia}
% }
% \affiliation{%
% \institution{$^1$Higher School of Economics}
% }
% \author{Artem Trofimov,$^ {1,2}$    Mikhail Shavkunov,$^3$    Sergey Reznick,$^4$     Nikita Sokolov,$^{5}$   Mikhail Yutman,$^3$ \\   Igor E. Kuralenok,$^1$    and  Boris Novikov$^ {3}$ }
% \affiliation{%
% \institution{$^1$JetBrains Research}
% }
% \affiliation{%
% \institution{$^2$Saint Petersburg State University}
% }
% \affiliation{%
% \institution{$^3$National Research University Higher School of Economics}
% }
% \affiliation{%
% \institution{$^4$ Kofax}
% }
% \affiliation{%
% \institution{$^5$ ITMO University}
%   \city{St. Petersburg}
%   \country{Russia}
% }
% \email{\string{trofimov9artem, mv.shavkunov, sergey.reznick, faucct, myutman, ikuralenok\string}@gmail.com, borisnov@acm.org}

\begin{abstract}

    There are two general ways to define computations: imperative and declarative.
    The first one is more transparent for programmers, while the second one is more suitable for complex optimizations.
    One declarative definition can have multiple implementations so that a system automatically chooses the most optimal one.
    Accordingly, distributed dataflow can be specified in two ways: defining concrete execution graph and SQL.
    A concrete graph does not capture high-level information about the problem it solves, so a distributed processing system cannot permute operations for performance purposes.
    Hence, graph optimization is generally a programmer concern, but real-world graphs can consist of many nodes that make it hard to optimize them manually.
    Moreover, most of the necessary information for the graph cost evaluation is available only in runtime.
    SQL is popular for data analytics, and its optimization is well-researched.
    However, it is inconvenient or sometimes impossible to use SQL for general data management tasks, such as ETL, machine learning pipelines, etc.

    In this work, we introduce a novel approach to specify distributed dataflows.
    Our method is based on declarative specifications of user-defined operations that we call contracts.
    Such specifications allow us to automatically generate execution graphs to choose the most optimal one.
    A contract can describe an arbitrary operation or a dataflow part, so this approach combines the transparency of the imperative approach and optimization possibilities of the declarative one.
    We implement a prototype and demonstrate automatic graphs generation on a real-world dataflow.
    We also outline the challenges that we face regarding the optimization problem.

\end{abstract}

% \begin{CCSXML}
% \begin{CCSXML}
% \begin{CCSXML}
% <ccs2012>
% <concept>
% <concept_id>10002951.10002952.10002953.10010820.10003208</concept_id>
% <concept_desc>Information systems~Data streams</concept_desc>
% <concept_significance>500</concept_significance>
% </concept>
% <concept>
% <concept_id>10002951.10003317.10003347.10003356</concept_id>
% <concept_desc>Information systems~Clustering and classification</concept_desc>
% <concept_significance>500</concept_significance>
% </concept>
% <concept>
% <concept_id>10002951.10003227.10003351.10003446</concept_id>
% <concept_desc>Information systems~Data stream mining</concept_desc>
% <concept_significance>300</concept_significance>
% </concept>
% </ccs2012>
% \end{CCSXML}

% \ccsdesc[500]{Information systems~Data streams}
% \ccsdesc[500]{Information systems~Clustering and classification}
% \ccsdesc[300]{Information systems~Data stream mining}

% \keywords{Data streams, text classification, reproducibility, exactly once}

\maketitle

\thispagestyle{empty}

\section{Introduction}
\input{calco-intro}
TODO

\section{Running example}
\input{calco-example}

\section{Calco overview}
% TODO Calco haskell
TODO

\section{Example evaluation}
% TODO Way of reasoning about problems by contracts in declarative way
% TODO Optimal graph in the generated set
% TODO Examples of graphs
% TODO Second example from SQL bench
% TODO Graphs generation time
TODO

\section{Discussion and future work}
% TODO General implementation
% TODO Better contracts interface (trello)
% TODO Smart advices

% TODO Preliminary cost evaluation
% TODO Runtime statistics gathering
% TODO Cost evaluation by statistics analysis
% TODO Actor entity that decides, whether to restructure execution graph
% TODO How to restructure execution graph in runtime

% TODO Only map-like elements in the stream
TODO

\section{Related work}
% TODO machine learning
% TODO graph queries processing
TODO

\section{Conclusion}
\input{calco-conclusion}

\bibliographystyle{ACM-Reference-Format}
\bibliography{../../bibliography/flame-stream}

\end{document}

\endinput
