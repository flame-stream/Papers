\label{fs-acker-tracker}

This section introduces a novel substream management framework called \tracker\ that is suitable for the cyclic dataflows and achieves a lower bound of network overhead. We also demonstrate that it provides all lifespan event properties defined in the previous section.

A substream management system should inform all processes that a substream ends, so the amount of extra traffic cannot be lower than $O(||\Pi||)$. To achieve this lower bound, one can apply an additional agent (process) that receives information about substreams from processes and sends back information about terminated substreams. 

In this case, the fact that substream ends is propagated through this agent without broadcasting between processes, so the amount of extra traffic can be linear by the number of processes. Such propagation method is suitable for cyclic dataflows because there is no need to forward service traffic through the cycles. Therefore, we design a {\em tracking agent} that:

\begin{enumerate}
    \item Receives signals that a substream terminated from data producers.
    \item Watches for in-flight elements and substreams.
    \item Notifies dataflow processes when the substream ends {\em for them}, i.e., when they do not receive any elements which satisfy some predicate.
\end{enumerate}

The general scheme of the \tracker\ mechanism is shown in Figure~\ref{tracker_scheme}. A special (possibly distributed) tracking agent receives signals from data sources, fetches information about in-flight elements, and then decides to send an {\em end-of-substream notification} (NEOSS). 

This way of propagation the information about substreams can be more efficient in terms of network traffic but provides new challenges. Before diving into implementation details, we should answer the following questions regarding \tracker\ framework:

{\bf Q1 How to organize monitoring of in-flight elements?} To detect that a substream ends, the tracking agent should receive the corresponding signal from data producers and ensure no in-flight elements belong to the substream. 

{\bf Q2 How to ensure bound guarantees?} While there are no longer special elements in the stream that denotes the substream end, we need to design other events that indicate the soft and firm substream bound. 

{\bf Q3 How to provide the consistent termination events order?} Unlike punctuations, \tracker\ notifications are completely async with dataflow elements because they go through another network channel. Hence, dataflow items and notifications are not ordered, making it hard to ensure that notifications order is consistent.

{\bf Q4 What are the functional and performance properties of \tracker?} \tracker\ framework is designed to eliminate the limitations of punctuations framework. We should demonstrate that it is suitable for cyclic dataflows as well as can provide lower network overhead.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.25\textwidth]{pics/tracker-scheme.pdf}
  \caption{\tracker\ framework: an example}
  \label{tracker_scheme}
\end{figure}

\subsection{Answering Q1: How to organize monitoring of in-flight elements?}
Assume that each process sends to tracking agent the following reports about each send or receive event which contain process (or {\em segment}) identifier and if this event satisfies predicate $pred(m)$.

Further in this paper, we will denote them as {\em SND report} and {\em RCV report}. Note that the result of applying predicates can be a vector if we are tracking multiple substreams. Process identifier is an optional field that can be used to send notifications independently for various processes or parts of the physical graph.

The tracking agent can monitor the existing substreams: if there are no reports for a specific predicate, the dataflow does not contain elements from the corresponding substream. Using this information along with signals from data producers, the tracking agent can detect when there is a soft guarantee that a substream ends.

A na\"ive implementation of the reports requires an extra network message for each input or output element of a process. However, as we show in the next section, reports can be aggregated and compressed within the process and sent to the tracking agent once per a fixed time period.

\subsection{Answering Q2: How to ensure bound guarantees?}

As we mentioned above, the tracking agent has enough information to detect the soft substream bound for each process. After detection, it can spawn end-of-substream notifications (NEOSS). Therefore, the termination event for the \tracker\ framework is generated iff a process $p$ has received the NEOSS, and there are no substream elements in the sendbox:

\begin{align*}
\langle eoss_{soft}, pred(m)\rangle \Longleftrightarrow \exists neoss \in B_p, \forall m\in B_p : \neg pred(m)
\end{align*}

To satisfy the firm notifications guarantee, one needs to hold elements that do not belong to the substream in the sendbox until NEOSS has arrived. This technique is quite similar to the punctuations alignment, mentioned in the previous section. If this condition is satisfied, then $\langle eoss_{firm}, pred(m)\rangle$ = $\langle eoss_{soft}, pred(m)\rangle$ for the \tracker. More formally, the sendbox procedure should ensure the following order of elements processing to achieve firm bound:

\begin{align*}
& \exists q \in I_p, e = \langle recv,m_{qp} \rangle : \neg pred(m_{qp}) \Longrightarrow \\ 
& \langle proc, m_{qp}\rangle >_p \langle eoss_{soft}, pred(m)\rangle
\end{align*} 

\subsection{Answering Q3: How to provide the consistent termination events order?}
In punctuations, such order is provided by design because punctuations and ordinary data items go through the same FIFO network channels, in \tracker\, this order should be enforced. Assume that SPE assigns to input data elements special totally ordered labels $t(m)$ and put this labels in $M$ as a metadata. All messages generated from the input one inherit the same label. 

In this case, if the order on $t(m)$ coincides with the order of input elements, then \tracker\ can produce the NEOSS events according to this order as well. In other words, \tracker\ can reorder the NEOSS events such that they will be consistent with the substreams order. An example of this concept is shown in Figure~\ref{tracker_ordering}. The substream containing element with $t(m)=1$ ends before the substream containing element with $t(m)=2$. As we can see, the order of NEOSS elements from \tracker\ coincides with $t(m)$.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.25\textwidth]{pics/tracker-ordering.pdf}
  \caption{\tracker\ framework: notifications order}
  \label{tracker_ordering}
\end{figure}

A vital question here is how to implement the assignment of ordered labels $t(m)$. One way is to use the {\em time oracle} service~\cite{10.14778/3055330.3055335} which can provide totally ordered labels. A simple alternative implementation is discussed in the next section. 

\subsection{Answering Q4: What are the functional and performance properties of \tracker?}

\tracker\ does not require regular broadcasting of the elements to all computational nodes because all service traffic goes through a single agent. This change of the method of the propagation the fact that the substream ends allows \tracker\ to have the following features by design:

\begin{enumerate}
    \item {\bf Cyclic dataflows support.} Because the tracking agent is monitoring for the properties of in-flight elements without direct injection of service items into a dataflow, \tracker\ does not have a problem of throwing them through a cycle.
    \item {\bf Low network overhead.} Processes can send reports once per a fixed time period, so there is a constant time of such reports per a finite substream. The reports require $O(|\Pi|)$ extra messages, while the NEOSS events $O(K|\Pi|)$. The total amount is $O(K|\Pi| + |\Pi|) = O(K|\Pi|)$ that is optimal for the substream management problem. 
    \item {\bf Low latency and impact on SPE throughput.} In \tracker, service traffic goes through other network channels than data elements. It can reduce latency between substream termination and the corresponding event because NEOSS cannot be blocked by ordinary elements. Together with the low amount of service traffic, this scheme does not significantly reduce the throughput of an SPE, as we show in Section~\ref{fs-experiments}.
\end{enumerate}

At the same time, \tracker\ can provide both soft and firm bound guarantees along with the consistent order of notifications. A limitation of the \tracker\ framework is a potentially more complex implementation than punctuations. The details of the straightforward implementation of the \tracker\ framework are discussed in the next section.