\label {fs-acker-intro}

Distributed stream processing engines (SPEs), such as Flink~\cite{carbone2015apache}, Heron~\cite{Kulkarni:2015:THS:2723372.2742788}, or MillWheel~\cite{Akidau:2013:MFS:2536222.2536229}, aim at handling potentially unbounded sequences of data elements. These systems receive input elements one-by-one, process them, update the internal in-memory state, and eventually release results. 

However, the processing of unbounded data sequences has at least two difficulties. First, SPEs should be aware of resource consumption. For instance, SPE can maintain an in-memory state with no upper bound in size and run out of memory. Second, SPEs observe elements sequentially, but traditional relational operators assume finite data sources with random access. Therefore, to produce correct results, there is a need to determine the ``bounds'' of the query.

In practice, infinite streams are often considered as a mixture of possibly finite substreams to deal with these difficulties. The examples of such scenarios are listed below.
\begin{enumerate}
    \item {\bf State pruning}. Most SPEs aggregate state by processing keys that are used for data partitioning. For example, if the task is to count the number of outgoing links from web pages, the page address would likely be the key. The problem here is that the state can grow unlimitedly~\cite{Tucker:2003:EPS:776752.776780}. To prevent overflow, SPE can remove state for outdated keys, e.g., for deleted web pages. In this case, we can consider the stream as a mixture of substreams, each of them can contain information about only some specific webpages.  
    \item {\bf Time windowed aggregations}. One way to produce results for a relational query is to process elements within event generation time windows. The time window can be considered as a substream. To release output, an SPE needs a guarantee that all data within a time window are received. This method is widely applied in online analytics~\cite{traub2018scotty} and is used for streaming SQL implementation~\cite{Begoli:2019:OSR:3299869.3314040}.
    \item {\bf State snapshotting}. Epoch-based state snapshotting is a popular recovery technique applied in Flink~\cite{Carbone:2017:SMA:3137765.3137777}, Storm~\cite{Toshniwal:2014:STO:2588555.2595641}, Samza~\cite{Noghabi:2017:SSS:3137765.3137770}, IBM Streams~\cite{jacques2016consistent}. Within this method, all input elements are divided into special substreams called {\em epochs}. An SPE takes a state snapshot when a regular epoch is {\em atomically} processed. In case of failures, SPE can consistently recover state from the snapshot~\cite{2015arXiv150608603C}. 
\end{enumerate}

Each of these scenarios can be considered as a special case of {\em substreams management problem}. This problem is to monitor for substreams emergence and termination. More formally, a substream is a part of the stream such that all its elements satisfy some predicate. For example, in the case of state pruning, the predicate is {\em [a data element may contain key $X$]}, while for time window aggregations, the predicate is {\em [a data element may be generated with timestamp less than $T$]}. 

Substreams can be finite or infinite. In this paper, we focus on substreams lifespan monitoring, so we consider finite substreams only. Note that various problems may require different properties of substream termination events:
\begin{itemize}
    \item Time windowed aggregations include some special scenarios, e.g., deterministic windowed join, that require an order of signals to be synchronized with the order of input elements (termination events from data producers)~\cite{najdataei2019stretch, gulisano2016scalejoin}.
    \item Epoch is a substream that an SPE should atomically process. Therefore, the event that an epoch ends should be received before any elements from the next epoch~\cite{2015arXiv150608603C}. 
    \item State pruning problem does not require any specific termination events properties. However, high latency between the actual substream termination (the event from data producer) and termination event receiving may reduce the efficiency of the technique.
\end{itemize}

A popular substreams management method is punctuations framework~\cite{tucker2003exploiting}. The main idea behind this framework is to divide the stream into substreams by injection of particular elements called {\em punctuations} that define the ``border'' of a substream. While the punctuations approach is robust and easy-to-implement, it has two limitations. First, it does not support cyclic dataflows in general because elements of a substream can be generated within a cycle~\cite{carbone2018scalable}. Second, it has high network traffic overhead due to network broadcasting of the ``border'' elements, so that punctuations can reduce the throughput of an SPE for small substreams~\cite{Li:2008:OPN:1453856.1453890}. 

In this work, we introduce a new substream management framework called \tracker. Within this framework, we introduce an additional agent (process) that receives information about substreams from an SPE and send them back substream lifespan events. In this case, the substream lifespan events are propagated through this agent, allowing SPE to reduce network traffic overhead significantly. Such propagation method is suitable for cyclic dataflows because there is no need to forward service traffic through the cycles.

By tackling these challenges, \tracker\ opens an ability to apply substreams-based techniques for new applications such as iterative stream processing and new setups, e.g., very granular substreams. We compare the performance of \tracker\ to the punctuations framework applied in most state-of-the-art SPEs. We demonstrate that \tracker\ outperforms punctuations within synthetic dataflow and a query from the Nexmark benchmark. We also show a novel application of the substream management problem for a real-world cyclic dataflow. 

As we can see, substreams management problem appears in many practical scenarios. Moreover, the features of some substreams impose requirements on the substream termination events. We formalize the substream management problem and generalize its properties. It allows us to ensure that our approach is suitable for the mentioned scenarios as well as for the more general problems that require substreams management.

In summary, our contributions are as follows:
\begin{enumerate}
    \item We formalize the substream management problem to be able to compare properties of various substream management systems.
    \item We present a novel substreams management framework that is more efficient than state-of-the-art alternatives and supports cyclic dataflows.
    \item We show that our framework is suitable for practical scenarios because it satisfies formal properties.
    \item We demonstrate \tracker\ performance in comparison to a state-of-the-art approach on diverse workloads.
\end{enumerate}

The rest of the paper is organized as follows: Section~\ref{fs-acker-preliminaries} formalizes the substream management problem and indicates the main properties of a solution. In Section~\ref{fs-acker-tracker}, we introduce a general design of the \tracker\ framework and demonstrate that it satisfies the formal properties of the substream management solution. Section~\ref{fs-acker-impl} summarizes the implementation of \tracker\ for both centralized and distributed setups with optimizations that can reduce the amount of extra traffic. In Section~\ref{fs-experiments}, we show that the proposed technique is scalable and can outperform alternatives employed in state-of-the-art stream processing engines. Finally, we discuss our conclusions in Section~\ref{fs-acker-conclusion}.