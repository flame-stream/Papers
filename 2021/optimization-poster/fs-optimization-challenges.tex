\label {sec:fs-optimization-challenges}

\textbf{Fetching and predicting statistics.} Cost-based optimization requires statistical information on data in order to calculate cost function values for each plan. However, upon the start of a streaming query execution no information about the data is available. Therefore, in order to properly apply cost-based optimization to streaming SQL queries, it is necessary to collect data statistics over the course of query execution; it's important to note that this should be implemented without significantly impacting the performance. Moreover, since we possess no definitive knowledge about the arriving data, in order to utilize an optimal plan for the upcoming windows, we need to predict statistics for each next window based on statistics for previous windows.

\textbf{Using statistics for query optimization.} The API of the current state-of-the-art systems typically utilizes a top-down approach to building a graph for query execution: first, a logical graph is created, then it is transformed into a physical graph, which is later used for execution, leaving no opportunity to pass any data from the physical level to the logical level and use it to adapt the graph to the new data and therefore making any runtime adjustments to execution plans impossible. Thus, the streaming systems API should be modified in order to make the passing of statistical information from the physical graph to the query planner possible.

\textbf{Execution graph migration at runtime.} Even if the optimal query execution plan was selected based upon statistics accumulated for previous windows, the new data statistics might be different enough to render the previous plan no longer optimal. In order to adapt to the changes in data, it's necessary to identify the moment in time in which the previous plan is no longer optimal for the current or upcoming data and to migrate the execution to a new graph. The graph migration could be implemented in a manner similar to the parallel track strategy \cite{zhu2004dynamic}, where the new execution graph is deployed alongside the old one, whose execution is terminated once it had finished processing the current window. Determining at which point the graph migration would be beneficial to perform (would cause a gain in performance despite the migration costs) is also a challenge.